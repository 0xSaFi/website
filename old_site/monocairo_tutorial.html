---
layout: obsolete
title: "Mono.Cairo Tutorial"
permalink: /old_site/Mono.Cairo_Tutorial/
redirect_from:
  - /Mono.Cairo_Tutorial/
---

<h1>Mono.Cairo Tutorial</h1>

<p>This tutorial is derived from Michael Urman's <a href="http://www.tortall.net/mu/wiki/CairoTutorial" class="external text" rel="nofollow">cairo tutorial</a> for python. The original code snippets have been translated to C#, the text has only been changed as much as necessary.  Translation to C# done by mgsloan.
</p><p>Cairo is a powerful 2d graphics library. This document introduces you to how
cairo works and many of the functions you will use to create the graphic
experience you desire.
</p><p>In order to follow along on your computer, you need the following things:
</p>
<ol><li> Cairo itself. You will need both the library and the development files. <a href="http://cairographics.org/download/" class="external text" rel="nofollow">Download it</a> if you don't have it already.
</li><li> <a href="{{site.github.url}}/Downloads" class="external text" rel="nofollow">Download Mono</a>, if you haven't already - you will need it to compile the C# code, and for the Mono.Cairo library.
</li></ol>
<pre> If you want to see the code snippets included in this tutorial in
 action, you can try to click on some of the images. You will get a
 small C# program which includes the described drawing code.
</pre>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Cairo.27s_Drawing_Model"><span class="tocnumber">1</span> <span class="toctext">Cairo's Drawing Model</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Nouns"><span class="tocnumber">1.1</span> <span class="toctext">Nouns</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="#Destination"><span class="tocnumber">1.1.1</span> <span class="toctext">Destination</span></a></li>
<li class="toclevel-3 tocsection-4"><a href="#Source"><span class="tocnumber">1.1.2</span> <span class="toctext">Source</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="#Mask"><span class="tocnumber">1.1.3</span> <span class="toctext">Mask</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#Path"><span class="tocnumber">1.1.4</span> <span class="toctext">Path</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Context"><span class="tocnumber">1.1.5</span> <span class="toctext">Context</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-8"><a href="#Verbs"><span class="tocnumber">1.2</span> <span class="toctext">Verbs</span></a>
<ul>
<li class="toclevel-3 tocsection-9"><a href="#Stroke"><span class="tocnumber">1.2.1</span> <span class="toctext">Stroke</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="#Fill"><span class="tocnumber">1.2.2</span> <span class="toctext">Fill</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#Show_Text_.2F_Glyphs"><span class="tocnumber">1.2.3</span> <span class="toctext">Show Text / Glyphs</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="#Paint"><span class="tocnumber">1.2.4</span> <span class="toctext">Paint</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#Mask_2"><span class="tocnumber">1.2.5</span> <span class="toctext">Mask</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#Drawing_with_Cairo"><span class="tocnumber">2</span> <span class="toctext">Drawing with Cairo</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="#Preparing_and_Selecting_a_Source"><span class="tocnumber">2.1</span> <span class="toctext">Preparing and Selecting a Source</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Creating_a_Path"><span class="tocnumber">2.2</span> <span class="toctext">Creating a Path</span></a>
<ul>
<li class="toclevel-3 tocsection-17"><a href="#Moving"><span class="tocnumber">2.2.1</span> <span class="toctext">Moving</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="#Straight_Lines"><span class="tocnumber">2.2.2</span> <span class="toctext">Straight Lines</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#Arcs"><span class="tocnumber">2.2.3</span> <span class="toctext">Arcs</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#Curves"><span class="tocnumber">2.2.4</span> <span class="toctext">Curves</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="#Close_the_path"><span class="tocnumber">2.2.5</span> <span class="toctext">Close the path</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="#Text"><span class="tocnumber">2.2.6</span> <span class="toctext">Text</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-23"><a href="#Understanding_Text"><span class="tocnumber">3</span> <span class="toctext">Understanding Text</span></a></li>
<li class="toclevel-1 tocsection-24"><a href="#Working_with_Transforms"><span class="tocnumber">4</span> <span class="toctext">Working with Transforms</span></a></li>
<li class="toclevel-1 tocsection-25"><a href="#Where_to_Go_Next"><span class="tocnumber">5</span> <span class="toctext">Where to Go Next</span></a></li>
<li class="toclevel-1 tocsection-26"><a href="#Tips_and_Tricks"><span class="tocnumber">6</span> <span class="toctext">Tips and Tricks</span></a>
<ul>
<li class="toclevel-2 tocsection-27"><a href="#Line_Width"><span class="tocnumber">6.1</span> <span class="toctext">Line Width</span></a></li>
<li class="toclevel-2 tocsection-28"><a href="#Text_Alignment"><span class="tocnumber">6.2</span> <span class="toctext">Text Alignment</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h2> <span class="mw-headline" id="Cairo.27s_Drawing_Model"> Cairo's Drawing Model </span></h2>
<p>In order to explain the operations used by cairo, we first delve into a
model of how cairo models drawing. There are only a few concepts
involved, which are then applied over and over by the different methods.
First I'll describe the <a href="#nouns">nouns</a>: <a href="#destination">destination</a>,
<a href="#source">source</a>, <a href="#mask">mask</a>, <a href="#path">path</a>, and <a href="#context">context</a>.
After that I'll describe the <a href="#verbs">verbs</a> which offer ways to manipulate
the nouns and draw the graphics you wish to create.
</p>
<h3> <span class="mw-headline" id="Nouns"> Nouns </span></h3>
<p>Cairo's nouns are somewhat abstract. To make them concrete I'm including
diagrams that depict how they interact. The first three nouns are the three
layers in the diagrams you see in this section. The fourth noun, the path, is
drawn on the middle layer when it is relevant. The final noun, the context,
isn't shown.
</p>
<h4> <span class="mw-headline" id="Destination"> Destination </span></h4>
<p><a href="{{site.github.url}}/images/old_site/a/a2/Cairo_destination.png" class="image"><img alt="Cairo destination.png" src="{{site.github.url}}/images/old_site/a/a2/Cairo_destination.png" width="160" height="120" /></a>
</p><p>The destination is the <a href="http://go-mono.com/docs/monodoc.ashx?link=T%3aCairo.Surface" class="external text" rel="nofollow">surface</a>
on which you're drawing. It may be tied to an array of pixels like in this
tutorial, or it might be tied to a SVG or PDF file, or something else.
This surface collects the elements of your graphic as you apply them,
allowing you to build up a complex work as though painting on a canvas.
</p>
<h4> <span class="mw-headline" id="Source"> Source </span></h4>
<p><a href="{{site.github.url}}/images/old_site/6/63/Cairo_source.png" class="image"><img alt="Cairo source.png" src="{{site.github.url}}/images/old_site/6/63/Cairo_source.png" width="160" height="120" /></a>
</p><p>The source is the "paint" you're about to work with. I show this as it
is&#8212;plain black for several examples&#8212;but translucent to show
lower layers.  Unlike real paint, it doesn't have to be a single color;
it can be a <a href="http://go-mono.com/docs/monodoc.ashx?link=T%3aCairo.Pattern" class="external text" rel="nofollow">pattern</a> or
even a previously created destination
<a href="http://go-mono.com/docs/monodoc.ashx?link=T%3aCairo.Surface" class="external text" rel="nofollow">surface</a>. Also
unlike real paint it can contain transparency information&#8212;the
Alpha channel.
</p>
<h4> <span class="mw-headline" id="Mask"> Mask </span></h4>
<p><a href="{{site.github.url}}/images/old_site/9/9d/Cairo_the-mask.png" class="image"><img alt="Cairo the-mask.png" src="{{site.github.url}}/images/old_site/9/9d/Cairo_the-mask.png" width="160" height="120" /></a>
</p><p>The mask is the most important piece: it controls where you apply
the source to the destination. I will show it as a yellow layer with holes
where it lets the source through. When you apply a drawing verb, it's like you
stamp the source to the destination. Anywhere the mask allows, the source is
copied. Anywhere the mask disallows, nothing happens.
</p>
<h4> <span class="mw-headline" id="Path"> Path </span></h4>
<p>The path is somewhere between part of the mask and part of the context. I will
show it as thin green lines on the mask layer. It is manipulated by path verbs,
then used by drawing verbs.
</p>
<h4> <span class="mw-headline" id="Context"> Context </span></h4>
<p>The context keeps track of everything that verbs affect. It tracks one source,
one destination, and one mask. It also tracks several helper variables like
your line width and style, your font face and size, and more. Most importantly
it tracks the path, which is turned into a mask by drawing verbs.
</p><p>Before you can start to draw something with cairo, you need to create
the <a href="http://go-mono.com/docs/monodoc.ashx?link=T%3aCairo.Context" class="external text" rel="nofollow">Context</a>.  
When you create a cairo context, it must be tied to a specific
<a href="http://go-mono.com/docs/monodoc.ashx?link=T%3aCairo.Surface" class="external text" rel="nofollow">Surface</a>
&#8212;for example, an <a href="http://go-mono.com/docs/monodoc.ashx?link=T%3aCairo.ImageSurface" class="external text" rel="nofollow">ImageSurface</a>
if you want to create a PNG file.  You can initialize your cairo context like this:
</p>
<code><pre>
ImageSurface surface = new ImageSurface(Format.RGV24, 120, 120);
Context cr = new Context(surface);
</pre></code>
<p>The cairo context in this example is tied to an image surface of
dimension 120&#160;x&#160;120 and 32 bits per pixel to store RGB and Alpha
information. Surfaces can be created specific to most cairo backends,
see the <a href="http://go-mono.com/docs/monodoc.ashx?tlink=0%40N%3aCairo" class="external text" rel="nofollow">manual</a> for details.
</p>
<h3> <span class="mw-headline" id="Verbs"> Verbs </span></h3>
<p>The reason you are using cairo in a program is to draw. Cairo internally draws
with one fundamental drawing operation: the source and mask are freely placed
somewhere over the destination. Then the layers are all pressed together and
the paint from the source is transferred to the destination wherever the mask
allows it. To that extent the following five drawing verbs, or operations, are
all similar. They differ by how they construct the mask.
</p>
<h4> <span class="mw-headline" id="Stroke"> Stroke </span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:162px;"><a href="{{site.github.url}}/images/old_site/b/b7/Cairo_stroke.png" class="image"><img alt="" src="{{site.github.url}}/images/old_site/b/b7/Cairo_stroke.png" width="160" height="120" class="thumbimage" /></a>  <div class="thumbcaption"><a href="http://mgsloan.nfshost.com/cairo_tut/stroke.cs" class="external text" rel="nofollow">View Source</a></div></div></div>
<p>The <a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.Stroke()" class="external text" rel="nofollow">Stroke</a>
operation takes a virtual pen along the path. It allows the source to
transfer through the mask in a thin (or thick) line around the path,
according to the pen's
<a href="http://go-mono.com/docs/monodoc.ashx?link=P%3aCairo.Context.LineWidth" class="external text" rel="nofollow">line width</a>,
<a href="http://go-mono.com/docs/monodoc.ashx?link=P%3aCairo.Context.LineCap" class="external text" rel="nofollow">line caps</a>,
<a href="http://go-mono.com/docs/monodoc.ashx?link=P%3aCairo.Context.LineJoin" class="external text" rel="nofollow">line join</a>,
and <a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.SetDash(System.Double%5b%5d%2cSystem.Double)" class="external text" rel="nofollow">dash style</a>.
</p>
<code><pre>
cr.LineWidth = 0.1;
cr.Color = new Color(0, 0, 0);
cr.Rectangle(0.25, 0.25, 0.5, 0.5);
cr.Stroke();
</pre></code>
<h4> <span class="mw-headline" id="Fill"> Fill </span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:162px;"><a href="{{site.github.url}}/images/old_site/7/7e/Cairo_fill.png" class="image"><img alt="" src="{{site.github.url}}/images/old_site/7/7e/Cairo_fill.png" width="160" height="120" class="thumbimage" /></a>  <div class="thumbcaption"><a href="http://mgsloan.nfshost.com/cairo_tut/fill.cs" class="external text" rel="nofollow">View Source</a></div></div></div>
<p>The <a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.Fill()" class="external text" rel="nofollow">Fill</a>
operation instead uses the path like the lines of a coloring book, and
allows the source through the mask within the hole whose boundaries are
the path. For complex paths (paths with multiple closed
sub-paths&#8212;like a donut&#8212;or paths that self-intersect) this is
influenced by the <a href="http://go-mono.com/docs/monodoc.ashx?link=P%3aCairo.Context.FillRule" class="external text" rel="nofollow">fill rule</a>.
Note that while stroking the path transfers the source for half of the
line width on each side of the path, filling a path fills directly up to
the edge of the path and no further.
</p>
<code><pre>
cr.Color = new Color(0, 0, 0);
cr.SetSourceRGB(0, 0, 0);
cr.Rectangle(0.25, 0.25, 0.5, 0.5);
cr.Fill();
</pre></code>
<h4> <span class="mw-headline" id="Show_Text_.2F_Glyphs"> Show Text / Glyphs </span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:162px;"><a href="{{site.github.url}}/images/old_site/2/2b/Cairo_showtext.png" class="image"><img alt="" src="{{site.github.url}}/images/old_site/2/2b/Cairo_showtext.png" width="160" height="120" class="thumbimage" /></a>  <div class="thumbcaption"><a href="http://mgsloan.nfshost.com/cairo_tut/showtext.cs" class="external text" rel="nofollow">View Source</a></div></div></div>
<p>The <a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.ShowText(System.String)" class="external text" rel="nofollow">ShowText</a>
operation forms the mask from text. It may be easier to think of
ShowText as a shortcut for creating a path with
<a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.TextPath(System.String)" class="external text" rel="nofollow">TextPath</a>
and then using
<a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.Fill()" class="external text" rel="nofollow">Fill</a>
to transfer it. Be aware that ShowText caches glyphs so is much
more efficient if you work with a lot of text.
</p>
<code><pre>
cr.Color = new Color(0, 0, 0);
cr.SelectFontFace(&quot;Georgia&quot;, FontSlant.Normal, FontWeight.Bold);
cr.SetFontSize(1.2);
TextExtents te = cr.TextExtents(&quot;a&quot;);
cr.MoveTo(0.5 - te.Width  / 2 - te.XBearing,
          0.5 - te.Height / 2 - te.YBearing);
cr.ShowText(&quot;a&quot;);
</pre></code>
<h4> <span class="mw-headline" id="Paint"> Paint </span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:162px;"><a href="{{site.github.url}}/images/old_site/8/83/Cairo_paint.png" class="image"><img alt="" src="{{site.github.url}}/images/old_site/8/83/Cairo_paint.png" width="160" height="120" class="thumbimage" /></a>  <div class="thumbcaption"><a href="http://mgsloan.nfshost.com/cairo_tut/paint.cs" class="external text" rel="nofollow">View Source</a></div></div></div>
<p>The <a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.Paint()" class="external text" rel="nofollow">Paint</a>
operation uses a mask that transfers the entire source to the
destination. Some people consider this an infinitely large mask, and
others consider it no mask; the result is the same. The related operation
<a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.PaintWithAlpha(System.Double)" class="external text" rel="nofollow">PaintWithAlpha</a>
similarly allows transfer of the full source to destination, but it
transfers only the provided percentage of the color.
</p>
<code><pre>
cr.Color = new Color(0, 0, 0);
cr.PaintWithAlpha(0.5);
</pre></code>
<h4> <span class="mw-headline" id="Mask_2"> Mask </span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:162px;"><a href="{{site.github.url}}/images/old_site/e/ee/Cairo_mask.png" class="image"><img alt="" src="{{site.github.url}}/images/old_site/e/ee/Cairo_mask.png" width="160" height="120" class="thumbimage" /></a>  <div class="thumbcaption"><a href="http://mgsloan.nfshost.com/cairo_tut/mask.cs" class="external text" rel="nofollow">View Source</a></div></div></div>
<p>The <a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.Mask(Cairo.Pattern)" class="external text" rel="nofollow">Mask</a>
and
<a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.MaskSurface(Cairo.Surface%2cSystem.Double%2cSystem.Double)" class="external text" rel="nofollow">MaskSurface</a>
operations allow transfer according to the transparency/opacity of a
second source pattern or surface. Where the pattern or surface is
opaque, the current source is transferred to the destination.  Where the
pattern or surface is transparent, nothing is transferred.
</p>
<code><pre>
Gradient linpat = new LinearGradient(0, 0, 1, 1);
linpat.AddColorStop(0, new Color(0, 0.3, 0.8));
linpat.AddColorStop(1, new Color(1, 0.8, 0.3));

Gradient radpat = new RadialGradient(0.5, 0.5, 0.25, 0.5, 0.5, 0.6);
radpat.AddColorStop(0, new Color(0, 0, 0, 1));
radpat.AddColorStop(1, new Color(0, 0, 0, 0));

cr.Source = linpat;
cr.Mask(radpat);
</pre></code>
<h2> <span class="mw-headline" id="Drawing_with_Cairo"> Drawing with Cairo </span></h2>
<p>In order to create an image you desire, you have to prepare the
<a href="http://go-mono.com/docs/monodoc.ashx?link=T%3aCairo.Context" class="external text" rel="nofollow">context</a> for
each of the drawing verbs. To use
<a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.Stroke()" class="external text" rel="nofollow">Stroke</a>
or
<a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.Fill()" class="external text" rel="nofollow">Fill</a>
you first need a path. To use
<a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.ShowText(System.String)" class="external text" rel="nofollow">ShowText</a>
you must position your text by its insertion point. To use
<a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.Mask(Cairo.Pattern)" class="external text" rel="nofollow">Mask</a>
you need a second source
<a href="http://go-mono.com/docs/monodoc.ashx?link=T%3aCairo.Pattern" class="external text" rel="nofollow">pattern</a> or
<a href="http://go-mono.com/docs/monodoc.ashx?link=T%3aCairo.Surface" class="external text" rel="nofollow">surface</a>.
And to use any of the operations, including
<a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.Paint()" class="external text" rel="nofollow">cairo_paint()</a>,
you need a primary source.
</p>
<h3> <span class="mw-headline" id="Preparing_and_Selecting_a_Source"> Preparing and Selecting a Source </span></h3>
<p>There are three main kinds of sources in cairo: colors, gradients, and
images. Colors are the simplest; they use a uniform hue and opacity for
the entire source. You can select these without any preparation by setting
the <a href="http://www.go-mono.com/docs/monodoc.ashx?link=P%3aCairo.Context.Color" class="external text" rel="nofollow">Color</a>
property.
</p>
<div class="thumb tright"><div class="thumbinner" style="width:122px;"><a href="{{site.github.url}}/images/old_site/c/cb/Cairo_setsourcergba.png" class="image"><img alt="" src="{{site.github.url}}/images/old_site/c/cb/Cairo_setsourcergba.png" width="120" height="120" class="thumbimage" /></a>  <div class="thumbcaption"><a href="http://mgsloan.nfshost.com/cairo_tut/setsourcergba.cs" class="external autonumber" rel="nofollow">[1]</a></div></div></div>
<code><pre>
cr.Color = new Color(0, 0, 0);
cr.MoveTo(0, 0);
cr.LineTo(1, 1);
cr.MoveTo(1, 0);
cr.LineTo(0, 1);
cr.LineWidth = 0.2;
cr.Stroke();

cr.Rectangle(0, 0, 0.5, 0.5);
cr.Color = new Color(1, 0, 0, 0.80);
cr.Fill();

cr.Rectangle(0, 0.5, 0.5, 0.5);
cr.Color = new Color(0, 1, 0, 0.60);
cr.Fill();

cr.Rectangle(0.5, 0, 0.5, 0.5);
cr.Color = new Color(0, 0, 0, 0.40);
cr.Fill();
</pre></code>
<p>Gradients describe a progression of colors by setting a start and stop
reference location and a series of "stops" along the way.
<a href="http://go-mono.com/docs/monodoc.ashx?link=T%3aCairo.LinearGradient" class="external text" rel="nofollow">Linear gradients</a>
are built from two points which pass through parallel lines to define
the start and stop locations. <a href="http://go-mono.com/docs/monodoc.ashx?link=T%3aCairo.RadialGradient" class="external text" rel="nofollow">Radial gradients</a>
are also built from two points, but each has an associated radius of the
circle on which to define the start and stop locations. Stops are added
to the gradient with
<a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Gradient.AddColorStop(System.Double%2cCairo.Color)" class="external text" rel="nofollow">AddColorStop</a>
and
<a href="http://go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Gradient.AddColorStopRgb(System.Double%2cCairo.Color)" class="external text" rel="nofollow">AddColorStopRgb</a>.
These methods take an offset (to indicate where it lies between the
reference locations) and color.  The colors between adjacent stops are
averaged over space to form a smooth blend.
</p>
<div class="thumb tright"><div class="thumbinner" style="width:122px;"><a href="{{site.github.url}}/images/old_site/1/19/Cairo_setsourcegradient.png" class="image"><img alt="" src="{{site.github.url}}/images/old_site/1/19/Cairo_setsourcegradient.png" width="120" height="120" class="thumbimage" /></a>  <div class="thumbcaption"><a href="http://mgsloan.nfshost.com/cairo_tut/setsourcegradient.cs" class="external text" rel="nofollow">View Source</a></div></div></div>
<code><pre>
Gradient radpat = new RadialGradient(0.25, 0.25, 0.1, 0.5, 0.5, 0.5);
radpat.AddColorStop(0, new Color(1.0, 0.8, 0.8));
radpat.AddColorStop(1, new Color(0.9, 0.0, 0.0));

for (int i=1; i&lt;10; i++)
    for (int j=1; j&lt;10; j++)
        cr.Rectangle(i/10.0 - 0.04, j/10.0 - 0.04, 0.08, 0.08);
cr.Source = radpat;
cr.Fill();

Gradient linpat = new LinearGradient(0.25, 0.35, 0.75, 0.65);
linpat.AddColorStop(0.00, new Color(1, 1, 1, 0));
linpat.AddColorStop(0.25, new Color(0, 1, 0, 0.5));
linpat.AddColorStop(0.50, new Color(1, 1, 1, 0));
linpat.AddColorStop(0.75, new Color(0, 0, 1, 0.5));
linpat.AddColorStop(1.00, new Color(1, 1, 1, 0));

cr.Rectangle(0.0, 0.0, 1, 1);
cr.Source = linpat;
cr.Fill();
</pre></code>
<p>Images include both surfaces loaded from existing files with
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a22%23ImageSurface%2fC%2f0" class="external text" rel="nofollow">ImageSurface(filename)</a>
and surfaces created from within cairo as an earlier destination. As of
cairo 1.2, the easiest way to make and use an earlier destination as a
source is with
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2fPushGroup" class="external text" rel="nofollow">PushGroup</a>
and either
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f61" class="external text" rel="nofollow">PopGroup</a>
or
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f62" class="external text" rel="nofollow">PopGroupToSource</a>.
</p><p>Use <code>PopGroupToSource</code> to use it just until you select a new
source, and <code>PopGroup</code> when you want to save it so you can
set the Context's Source to it repeatedly.
</p>
<h3> <span class="mw-headline" id="Creating_a_Path"> Creating a Path </span></h3>
<p>Cairo always has an active path. If you call <a href="#Stroke">Stroke</a> it will draw the path with your
line settings. If you call <a href="#Fill">Fill</a> it will fill the inside of the
path. But as often as not, the path is empty, and both calls will result
in no change to your destination. Why is it empty so often? For one, it
starts that way; but more importantly after each <a href="#Stroke">Stroke</a> or
<a href="#Fill">Fill</a> it is emptied again to let you start building your next
path.
</p><p>What if you want to do multiple things with the same path? For instance to draw
a red rectangle with a black border, you would want to fill the rectangle path
with a red source, then stroke the same path with a black source. A rectangle
path is easy to create multiple times, but a lot of paths are more complex.
</p><p>Cairo supports easily reusing paths by having alternate versions of its
operations. Both draw the same thing, but the alternate doesn't reset
the path.  For stroking, alongside
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f14" class="external text" rel="nofollow">Stroke</a>
there is
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f28" class="external text" rel="nofollow">Stroke Preserve</a>;
for filling, <a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f16" class="external text" rel="nofollow">FillPreserve</a>
joins <a href="http://www.go-mono.com/docs/index.aspx?tlink=0@ecma%3a4%23Context%2fM%2f15" class="external text" rel="nofollow">Fill</a>.
Even setting the clip has a preserve variant.  Apart from choosing when
to preserve your path, there are only a couple common operations.
</p>
<h4> <span class="mw-headline" id="Moving"> Moving </span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:122px;"><a href="{{site.github.url}}/images/old_site/1/1c/Cairo_path-moveto.png" class="image"><img alt="Cairo path-moveto.png" src="{{site.github.url}}/images/old_site/1/1c/Cairo_path-moveto.png" width="120" height="120" class="thumbimage" /></a>  <div class="thumbcaption"></div></div></div>
<p>Cairo uses a connect-the-dots style system when creating paths.  Start
at 1, draw a line to 2, then 3, and so forth. When you start a path, or
when you need to start a new sub-path, you want it to be like point 1:
it has nothing connecting to it. For this, use
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2fMoveTo" class="external text" rel="nofollow">MoveTo</a>.
This sets the current reference point without making the path connect
the previous point to it. There is also a relative coordinate variant,
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2fRelMoveTo" class="external text" rel="nofollow">RelMoveTo</a>,
which sets the new reference a specified distance away from the current
reference instead. After setting your first reference point, use the
other path operations which both update the reference point and connect
to it in some way.
</p>
<code><pre>
cr.MoveTo(0.25, 0.25);
</pre></code>
<h4> <span class="mw-headline" id="Straight_Lines"> Straight Lines </span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:122px;"><a href="{{site.github.url}}/images/old_site/a/a1/Cairo_path-lineto.png" class="image"><img alt="Cairo path-lineto.png" src="{{site.github.url}}/images/old_site/a/a1/Cairo_path-lineto.png" width="120" height="120" class="thumbimage" /></a>  <div class="thumbcaption"></div></div></div>
<p>Whether with absolute coordinates
<a href="http://www.go-mono.com/docs/index.aspx?tlink=0@ecma%3a4%23Context%2fM%2f15" class="external text" rel="nofollow">LineTo</a>
(extend the path from the reference to this point), or relative coordinates
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2fRelLineTo" class="external text" rel="nofollow">RelLineTo</a>
(extend the path from the reference this far in this direction), the
path connection will be a straight line. The new reference point will be
at the other end of the line.
</p>
<code><pre>
cr.LineTo(0.5, 0.375);
cr.RelLineTo(0.25, -0.125);
</pre></code>
<h4> <span class="mw-headline" id="Arcs"> Arcs </span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:122px;"><a href="{{site.github.url}}/images/old_site/1/1e/Cairo_path-arcto.png" class="image"><img alt="Cairo path-arcto.png" src="{{site.github.url}}/images/old_site/1/1e/Cairo_path-arcto.png" width="120" height="120" class="thumbimage" /></a>  <div class="thumbcaption"></div></div></div>
<p>Arcs are parts of the outside of a circle. Unlike straight lines, the
point you directly specify is not on the path. Instead it is the center
of the circle that makes up the addition to the path. Both a starting
and ending point on the circle must be specified, and these points are
connected either clockwise by
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f10" class="external text" rel="nofollow">Arc</a>
or counter-clockwise by
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f11" class="external text" rel="nofollow">ArcNegative</a>
If the previous reference point is not on this new curve, a straight
line is added from it to where the arc begins. The reference point is
then updated to where the arc ends. There are only absolute versions.
</p>
<code><pre>
cr.Arc(0.5, 0.5, 0.25 * Math.Sqrt(2), -0.25 * Math.PI, 0.25 * Math.PI);
</pre></code>
<h4> <span class="mw-headline" id="Curves"> Curves </span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:122px;"><a href="{{site.github.url}}/images/old_site/c/c4/Cairo_path-curveto.png" class="image"><img alt="Cairo path-curveto.png" src="{{site.github.url}}/images/old_site/c/c4/Cairo_path-curveto.png" width="120" height="120" class="thumbimage" /></a>  <div class="thumbcaption"></div></div></div>
<p>Curves in cairo are cubic BÃ©zier splines. They start at the current
reference point and smoothly follow the direction of two other points
(without going through them) to get to a third specified point. Like
lines, there are both absolute
(<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2fCurveTo" class="external text" rel="nofollow">CurveTo</a>)
and relative
(<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2fRelCurveTo" class="external text" rel="nofollow">RelCurveTo</a>)
versions. Note that the relative variant specifies all points relative
to the previous reference point, rather than each relative to the
preceding control point of the curve.
</p>
<code><pre>
cr.RelCurveTo(-0.25, -0.125, -0.25, 0.125, -0.5, 0);
</pre></code>
<h4> <span class="mw-headline" id="Close_the_path"> Close the path </span></h4>
<div class="thumb tright"><div class="thumbinner" style="width:122px;"><a href="{{site.github.url}}/images/old_site/d/d0/Cairo_path-close.png" class="image"><img alt="" src="{{site.github.url}}/images/old_site/d/d0/Cairo_path-close.png" width="120" height="120" class="thumbimage" /></a>  <div class="thumbcaption"><a href="http://mgsloan.nfshost.com/cairo_tut/path-close.cs" class="external text" rel="nofollow">View Source</a></div></div></div>
<p>Cairo can also close the path by drawing a straight line to the
beginning of the current sub-path. This straight line can be useful for
the last edge of a polygon, but is not directly useful for curve-based
shapes. A closed path is fundamentally different from an open path: it's
one continuous path and has no start or end. A closed path has no line
caps for there is no place to put them.
</p>
<code><pre>
cr.ClosePath();
</pre></code>
<h4> <span class="mw-headline" id="Text"> Text </span></h4>
<p>Finally text can be turned into a path with
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f27" class="external text" rel="nofollow">TextPath</a>.
Paths created from text are like any other path, supporting stroke or
fill operations. This path is placed anchored to the current reference
point, so <a href="#Moving">MoveTo</a> your desired location before turning text
into a path. However there are performance concerns to doing this if
you are working with a lot of text; when possible you should prefer using
the verb <a href="#Show_Text_.2F_Glyphs"> ShowText</a> over TextPath and
<a href="http://www.go-mono.com/docs/index.aspx?tlink=0@ecma%3a4%23Context%2fM%2f15" class="external text" rel="nofollow">Fill</a>.
</p>
<h2> <span class="mw-headline" id="Understanding_Text"> Understanding Text </span></h2>
<div class="thumb tright"><div class="thumbinner" style="width:122px;"><a href="{{site.github.url}}/images/old_site/9/9d/Cairo_textextents.png" class="image"><img alt="" src="{{site.github.url}}/images/old_site/9/9d/Cairo_textextents.png" width="120" height="120" class="thumbimage" /></a>  <div class="thumbcaption"><a href="http://mgsloan.nfshost.com/cairo_tut/textextents.cs" class="external text" rel="nofollow">View Source</a></div></div></div>
<p>To use text effectively you need to know where it will go. The methods
<a href="http://www.go-mono.com/docs/monodoc.ashx?link=P%3aCairo.Context.FontExtents" class="external text" rel="nofollow">FontExtents</a>
and
<a href="http://www.go-mono.com/docs/monodoc.ashx?link=M%3aCairo.Context.TextExtents(System.String)" class="external text" rel="nofollow">TextExtents</a>
get you this information. Since this diagram is hard to see so small, I
suggest getting its <a href="http://mgsloan.nfshost.com/cairo_tut/textextents.cs" class="external text" rel="nofollow">source</a> and bump the size up to 600. It shows the
relation between the reference point (red dot); suggested next reference
point (blue dot); bounding box (dashed blue lines); bearing displacement
(solid blue line); and height, ascent, baseline, and descent lines
(dashed green).
</p><p>The reference point is always on the baseline. The descent line is below that,
and reflects a rough bounding box for all characters in the font. However it is
an artistic choice intended to indicate alignment rather than a true bounding
box. The same is true for the ascent line above. Next above that is the height
line, the artist-recommended spacing between subsequent baselines. All three of
these are reported as distances from the baseline, and expected to be positive
despite their differing directions.
</p><p>The bearing is the displacement from the reference point to the upper-left
corner of the bounding box. It is often zero or a small positive value for x
displacement, but can be negative x for characters like j as shown; it's almost
always a negative value for y displacement. The width and height then describe
the size of the bounding box. The advance takes you to the suggested reference
point for the next letter. Note that bounding boxes for subsequent blocks of
text can overlap if the bearing is negative, or the advance is smaller than the
width would suggest.
</p><p>In addition to placement, you also need to specify a face, style, and
size. Set the face and style together with
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f50" class="external text" rel="nofollow">SelectFontFace</a>,
and the size with
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f51" class="external text" rel="nofollow">SetFontSize</a>.
If you need even finer control, try modifying a
<a href="http://www.go-mono.com/docs/monodoc.ashx?link=T%3aCairo.FontOptions" class="external text" rel="nofollow">FontOptions struct</a>
with
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fP%2f19" class="external text" rel="nofollow">FontOptions property</a>.
</p>
<h2> <span class="mw-headline" id="Working_with_Transforms"> Working with Transforms </span></h2>
<p>Transforms have three major uses. First they allow you to set up a
coordinate system that's easy to think in and work in, yet have the
output be of any size. Second they allow you to make helper functions
that work at or around a (0, 0) but can be applied anywhere in the
output image. Thirdly they let you deform the image, turning a circular
arc into an elliptical arc, etc. Transforms are a way of setting up a
relation between two coordinate systems. The device-space coordinate
system is tied to the surface, and cannot change. The user-space
coordinate system matches that space by default, but can be changed for
the above reasons. The helper functions
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f53" class="external text" rel="nofollow">TransformPoint</a>
and
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f54" class="external text" rel="nofollow">TransformDistance</a>
tell you what the device-coordinates are for a user-coordinates position
or distance.  Correspondingly
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f55" class="external text" rel="nofollow">InverseTransformPoint</a>
and
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f56" class="external text" rel="nofollow">InverseTransformDistance</a>
tell you user-coordinates for a device-coordinates position or distance.
Remember to send positions through the non-distance variant, and
relative moves or other distances through the distance variant.
</p><p>I leverage all of these reasons to draw the diagrams in this document.
Whether I'm drawing 120&#160;x&#160;120 or 600&#160;x&#160;600, I use
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f21" class="external text" rel="nofollow">Scale</a>
to give me a 1.0&#160;x&#160;1.0 workspace. To place the results along
the right column, such as in the discussion of <a href="#Drawing_Model"> cairo's drawing model</a>, I use
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f22" class="external text" rel="nofollow">Translate</a>.
And to add the perspective view for the overlapping layers, I set up an
arbitrary deformation with
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f52" class="external text" rel="nofollow">Transform</a>.
</p><p>To understand your transforms, read them bottom to top, applying them to the
point you're drawing. To figure out which transforms to create, think through
this process in reverse. For example if I want my 1.0&#160;x&#160;1.0 workspace to be
100&#160;x&#160;100 pixels in the middle of a 120&#160;x&#160;120 pixel surface, I can set it up one of
three ways:
</p>
<ol><li> <code>cr.Translate(10, 10); cr.Scale(100, 100); </code>
</li><li> <code>cr.Scale(100, 100); cr.Translate(0.1, 0.1); </code>
</li><li> <code>cr.Transform(Matrix(100, 0, 0, 100, 10, 10)); </code>
</li></ol>
<p>Use the first when relevant because it is often the most readable; use the
third when necessary to access additional control not available with the
primary functions.
</p><p>Be careful when trying to draw lines while under transform. Even if you
set your line width while the scale factor was 1, the line width setting
is always in user-coordinates and isn't modified by setting the scale.
While you're operating under a scale, the width of your line is
multiplied by that scale. To specify a width of a line in pixels, use
<a href="http://www.go-mono.com/docs/monodoc.ashx?tlink=0@ecma%3a4%23Context%2fM%2f56" class="external text" rel="nofollow">InverseTransformDistance</a>
to turn a <code>(1, 1)</code> device-space distance into, for example, a <code>(0.01,
0.01)</code> user-space distance. Note that if your transform deforms the
image there isn't necessarily a way to specify a line with a uniform
width.
</p>
<h2> <span class="mw-headline" id="Where_to_Go_Next"> Where to Go Next </span></h2>
<p>This wraps up the tutorial. It doesn't cover all functions in cairo, so
for some "advanced" lesser-used features, you'll need to look elsewhere.
More examples of cairo use, in other languages, may be found on
&lt;a href="www.cairographics.org/examples"&gt;cairographics.org&lt;/a&gt;.  As
with everything, there's a large gap between knowing the rules of the
tool, and being able to use it well. The final section of this document
provides some ideas to help you traverse parts of the gap.
</p>
<h2> <span class="mw-headline" id="Tips_and_Tricks"> Tips and Tricks </span></h2>
<p>In the previous sections you should have built up a firm grasp of the
operations cairo uses to create images. In this section I've put together a
small handful of snippets I've found particularly useful or non-obvious. I'm
still new to cairo myself, so there may be other better ways to do these
things. If you find a better way, or find a cool way to do something else, let
me know and perhaps I can incorporate it into these tips.
</p>
<h3> <span class="mw-headline" id="Line_Width"> Line Width </span></h3>
<p>When you're working under a uniform scaling transform, you can't just
use pixels for the width of your line. However it's easy to translate it
with the help of <code>InverseTransformDistance</code> (assuming that the
pixel width is <code>1</code>):
</p>
<code><pre>
double ux=1, uy=1;
cr.InverseTransformDistance(ref ux, ref uy);
cr.LineWidth = Math.Max(ux, uy);
</pre></code>
<p>When you're working under a deforming scale, you may wish to still have line
widths that are uniform in device space. For this you should return to a
uniform scale before you stroke the path. In the image, the arc on the left is
stroked under a deformation, while the arc on the right is stroked under a
uniform scale.
</p>
<div class="thumb tright"><div class="thumbinner" style="width:122px;"><a href="{{site.github.url}}/images/old_site/5/59/Cairo_tips-ellipse.png" class="image"><img alt="" src="{{site.github.url}}/images/old_site/5/59/Cairo_tips-ellipse.png" width="120" height="120" class="thumbimage" /></a>  <div class="thumbcaption"><a href="http://mgsloan.nfshost.com/tips-ellipse.cs" class="external text" rel="nofollow">View Source</a></div></div></div>
<code><pre>
cr.LineWidth = 0.1;

cr.Save();
cr.Scale(0.5, 1);
cr.Arc(0.5, 0.5, 0.40, 0, 2 * Math.PI);
cr.Stroke();

cr.Translate(1, 0);
cr.Arc(0.5, 0.5, 0.40, 0, 2 * Math.PI);
cr.Restore();
cr.Stroke();
</pre></code>
<h3> <span class="mw-headline" id="Text_Alignment"> Text Alignment </span></h3>
<p>When you try to center text letter by letter at various locations, you have to
decide how you want to center it. For example the following code will actually
center letters individually, leading to poor results when your letters are of
different sizes. (Unlike most examples, here I assume a 26&#160;x&#160;1 workspace.)
</p>
<div class="thumb tright"><div class="thumbinner" style="width:782px;"><a href="{{site.github.url}}/images/old_site/c/ce/Cairo_tips-letter.png" class="image"><img alt="" src="{{site.github.url}}/images/old_site/c/ce/Cairo_tips-letter.png" width="780" height="30" class="thumbimage" /></a>  <div class="thumbcaption"><a href="http://mgsloan.nfshost.com/tips-letter.cs" class="external text" rel="nofollow">View Source</a></div></div></div>
<p><br /><br /><br /><br /><br /><br /><br />
</p>
<code><pre>
FontExtents fe = cr.FontExtents;
string alph = &quot;AbCdEfGhIjKlMnOpQrStUvWxYz&quot;;
for(int i = 0; i &lt; alph.Length; i++) {
	string str = alph.Substring(i, 1);
	TextExtents te = cr.TextExtents(str);
	cr.MoveTo(i + 0.5 - te.XBearing - te.Width  / 2,
                  0.5 - te.YBearing + fe.Height / 2);
	cr.ShowText(str);
}
</pre></code>
<p>Instead the vertical centering must be based on the general size of the font,
thus keeping your baseline steady. Note that the exact positioning now depends
on the metrics provided by the font itself, so the results are not necessarily
the same from font to font.
</p>
<div class="thumb tright"><div class="thumbinner" style="width:782px;"><a href="{{site.github.url}}/images/old_site/b/b8/Cairo_tips-font.png" class="image"><img alt="" src="{{site.github.url}}/images/old_site/b/b8/Cairo_tips-font.png" width="780" height="30" class="thumbimage" /></a>  <div class="thumbcaption"><a href="http://mgsloan.nfshost.com/tips-font.cs" class="external text" rel="nofollow">View Source</a></div></div></div>
<p><br /><br /><br /><br /><br /><br /><br />
</p>
<code><pre>
FontExtents fe = cr.FontExtents;
string alph = &quot;AbCdEfGhIjKlMnOpQrStUvWxYz&quot;;
for(int i = 0; i &lt; alph.Length; i++) {
	string str = alph.Substring(i, 1);
	TextExtents te = cr.TextExtents(str);
	cr.MoveTo(i + 0.5 - te.XBearing - te.Width  / 2,
                      0.5 - fe.Descent + fe.Height / 2);
	cr.ShowText(str);
}
</pre></code>

