---
layout: obsolete
title: "Mono:Runtime:Documentation:GenericSharing"
permalink: /old_site/Mono:Runtime:Documentation:GenericSharing/
redirect_from:
  - /Mono:Runtime:Documentation:GenericSharing/
---

<h1>Mono:Runtime:Documentation:GenericSharing</h1>

<p>This describes the technology used in Mono's Virtual Machine to share code when instantiating generic classes by Mark Probst, Novell.
</p>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Porting"><span class="tocnumber">1</span> <span class="toctext">Porting</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Generic_class_init_trampoline"><span class="tocnumber">1.1</span> <span class="toctext">Generic class init trampoline</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#RGCTX_register"><span class="tocnumber">1.2</span> <span class="toctext">RGCTX register</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Method_prologue"><span class="tocnumber">1.3</span> <span class="toctext">Method prologue</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Dealing_with_types"><span class="tocnumber">1.4</span> <span class="toctext">Dealing with types</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#.28M.29RGCTX_lazy_fetch_trampoline"><span class="tocnumber">1.5</span> <span class="toctext">(M)RGCTX lazy fetch trampoline</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#Getting_generics_information_about_a_stack_frame"><span class="tocnumber">2</span> <span class="toctext">Getting generics information about a stack frame</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Layout_of_the_MRGCTX"><span class="tocnumber">3</span> <span class="toctext">Layout of the MRGCTX</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#Blog_posts_about_generic_code_sharing"><span class="tocnumber">4</span> <span class="toctext">Blog posts about generic code sharing</span></a></li>
</ul>
</td></tr></table>
<h1> <span class="mw-headline" id="Porting"> Porting </span></h1>
<p>This describes how to port the generic code sharing infrastructure in Mono.   This is in addition to the <a href="{{site.github.url}}/old_site/Mono:Runtime:Documentation:MiniPorting" title="Mono:Runtime:Documentation:MiniPorting">Mono Runtime Porting</a> instructions.
</p>
<h2> <span class="mw-headline" id="Generic_class_init_trampoline"> Generic class init trampoline </span></h2>
<p>The generic class init trampoline is very similar to the class init trampoline, with the exception that the VTable of the class to be inited is passed in a register, <code>MONO_ARCH_VTABLE_REG</code>.  That register can be the same as the IMT register. 
</p><p>The call to the generic class init trampoline is never patched because the VTable is not constant - it depends on the type arguments of the class/method doing the call to the trampoline.  For that reason, the trampoline needs a fast path for the case that the class is already inited, i.e. the trampoline needs to check the initialized bit of the MonoVTable and immediately return if it is set.  See tramp-x86.c for how to portably figure out the number of the bit in the bit-field that needs to be checked.  Since the <code>MONO_ARCH_VTABLE_REG</code> is needed by the generic class init trampoline function (in mini-trampolines.c) it needs to be saved by the generic trampoline code in the register save block which is passed to the trampoline.  This also applies to the RGCTX fetch trampoline (see below).
</p><p>Like the normal class init trampoline, the result of the generic class init trampoline function is not a pointer to code that needs to be jumped to.  Instead, just like for the class init trampoline, the generic trampoline code must return to the caller instead of jumping to the returned value.  The same applies for the RGCTX fetch trampoline (see below).
</p>
<h2> <span class="mw-headline" id="RGCTX_register"> RGCTX register </span></h2>
<p>Generic shared code needs access to type information.  This information is contained in a RGCTX for non-generic methods and in an MRGCTX for generic methods.  It is passed in one of several ways, depending on the type of the called method:
</p>
<ol><li> Non-generic non-static methods of reference types have access to the RGCTX via the "this" argument (this-&gt;vtable-&gt;rgctx).
</li></ol>
<ol><li> Non-generic static methods of reference types and non-generic methods of value types need to be passed a pointer to the caller's class's VTable in the MONO_ARCH_RGCTX_REG register.
</li></ol>
<ol><li> Generic methods need to be passed a pointer to the MRGCTX in the <code>MONO_ARCH_RGCTX_REG</code> register.
</li></ol>
<p>The <code>MONO_ARCH_RGCTX_REG</code> must not be clobbered by trampolines.
</p><p><code>MONO_ARCH_RGCTX_REG</code> can be the same as the IMT register for now, but this might change in the future when we implement virtual generic method calls (more) efficiently.
</p><p>This register lifetime starts at the call site that loads it and ends in the callee prologue when it is either discarded or stored into a local variable.
</p><p>It's better to avoid registers used for argument passing for the RGCTX as it would make the code dealing with calling conventions code a lot harder.
</p>
<h2> <span class="mw-headline" id="Method_prologue"> Method prologue </span></h2>
<p>Generic shared code that have a <code>RGCTX</code> receive it in <code>RGCTX_REG</code>.  There must be a check in mono_arch_emit_prolog for MonoCompile::rgctx_var and if set store it.  See mini-x86.c for reference.
</p>
<h2> <span class="mw-headline" id="Dealing_with_types"> Dealing with types </span></h2>
<p>Types passed to arch functions might be type parameters (<code>MONO_TYPE_(M)VAR</code>) if the <code>MonoGenericSharingContext*</code> argument is non-NULL.  For example, an argument or return type in a method passed to <code>mono_arch_find_this_argument()</code> could be a <code>MONO_TYPE_VAR</code>.  To guard for that case use <code>mini_get_basic_type_from_generic()</code> on the type.  See <code>get_call_info()</code> in mini-x86.c, for example.
</p>
<h2> <span class="mw-headline" id=".28M.29RGCTX_lazy_fetch_trampoline"> (M)RGCTX lazy fetch trampoline </span></h2>
<p>The purpose of the lazy fetch trampoline is to fetch a slot from an (M)RGCTX which might not be inited, yet.  In the latter case, it needs to go make a transition to unmanaged code to fill the slot.  This is the layout of a RGCTX:
</p>
<pre>
     +---------------------------------+
     | next | slot 0 | slot 1 | slot 2 |
     +--|------------------------------+
        |
  +-----+
  |  +---------------------------------
  +-&gt;| next | slot 3 | slot 4 | slot 5 ....
     +--|------------------------------
        |
  +-----+
  |  +------------------------------------
  +-&gt;| next | slot 10 | slot 11 | slot 12 ....
     +--|---------------------------------
        .
        .
        .
</pre>
<p>For fetching a slot from a RGCTX the trampoline is passed a pointer (as a normal integer argument) to the VTable.  From there it has to fetch the pointer to the RGCTX, which might be null.  Then it has to traverse the correct number of "next" links, each of which might be NULL.  Arriving at the right array it needs to fetch the slot, which might also be NULL.  If any of the NULL cases, the trampoline must transition to unmanaged code to potentially setup the RGCTX and fill the slot.  Here is pseudo-code for fetching slot 11:
</p>
<pre>
   &#160;; vtable ptr in r1
   &#160;; fetch RGCTX array 0
    r2 = *(r1 + offsetof(MonoVTable, runtime_generic_context))
    if r2 == NULL goto unmanaged
   &#160;; fetch RGCTX array 1
    r2 = *r2
    if r2 == NULL goto unmanaged
   &#160;; fetch RGCTX array 2
    r2 = *r2
    if r2 == NULL goto unmanaged
   &#160;; fetch slot 11
    r2 = *(r2 + 2 * sizeof (gpointer))
    if r2 == NULL goto unmanaged
    return r2
  unmanaged:
    jump unmanaged_fetch_code
</pre>
<p>The number of slots in the arrays must be obtained from the function <code>mono_class_rgctx_get_array_size()</code>.
</p><p>The MRGCTX case is different in two aspects.  First, the trampoline is not passed a pointer to a VTable, but a pointer directly to the MRGCTX, which is guaranteed not to be NULL (any of the next pointers and any of the slots can be NULL, though).  Second, the layout of the first array is slightly different, in that the first two slots are occupied by a pointers to the class's VTable and to the method's method_inst.  The next pointer is in the third slot and the first actual slot, "slot 0", in the fourth:
</p>
<pre>
     +--------------------------------------------------------+
     | vtable | method_inst | next | slot 0 | slot 1 | slot 2 |
     +-------------------------|------------------------------+
                               .
                               .
</pre>
<p>All other arrays have the same layout as the RGCTX ones, except possibly for their length.
</p><p>The function to create the trampoline, mono_arch_create_rgctx_lazy_fetch_trampoline(), gets passed an encoded slot number.  Use the macro <code>MONO_RGCTX_SLOT_IS_MRGCTX</code> to query whether a trampoline for an MRGCTX is needed, as opposed to one for a RGCTX.  Use <code>MONO_RGCTX_SLOT_INDEX</code> to get the index of the slot (like 2 for "slot 2" as above).  The unmanaged fetch code is yet another trampoline created via <code>mono_arch_create_specific_trampoline()</code>, of type <code>MONO_TRAMPOLINE_RGCTX_LAZY_FETCH</code>.  It's given the slot number as the trampoline argument.  In addition, the pointer to the VTable/MRGCTX is passed in <code>MONO_ARCH_VTABLE_REG</code> (like the VTable to the generic class init trampoline - see above).
</p><p>Like the class init and generic class init trampolines, the RGCTX fetch trampoline code doesn't return code that must be jumped to, so, like for those trampolines (see above), the generic trampoline code must do a normal return instead.
</p>
<h1> <span class="mw-headline" id="Getting_generics_information_about_a_stack_frame"> Getting generics information about a stack frame </span></h1>
<p>If a method is compiled with generic sharing, its <code>MonoJitInfo</code> has <code>has_generic_jit_info</code> set.  In that case, the <code>MonoJitInfo</code> is followed (after the <code>MonoJitExceptionInfo</code> array) by a <code>MonoGenericJitInfo</code>.
</p><p>The MonoGenericJitInfo contains information about the location of the this/vtable/MRGCTX variable, if the has_this flag is set.  If that is the case, there are two possibilities:
</p>
<ol><li> this_in_reg is set.  this_reg is the number of the register where the variable is stored.
</li></ol>
<ol><li> this_in_reg is not set.  The variable is stored at offset      this_offset from the address in the register with number      this_reg.
</li></ol>
<p>The variable can either point to the "this" object, to a vtable or to
an MRGCTX:
</p>
<ol><li> If the method is a non-generic non-static method of a reference type, the variable points to the "this" object.
</li></ol>
<ol><li> If the method is a non-generic static method or a non-generic method of a value type, the variable points to the vtable of the      class.
</li></ol>
<ol><li> If the method is a generic method, the variable points to the MRGCTX of the method.
</li></ol>
<h1> <span class="mw-headline" id="Layout_of_the_MRGCTX"> Layout of the MRGCTX </span></h1>
<p>The MRGCTX is a structure that starts with <code>MonoMethodRuntimeGenericContext</code>, which contains a pointer to the vtable of the class and a pointer to the <code>MonoGenericInst</code> with the type arguments for the method.
</p>
<h1> <span class="mw-headline" id="Blog_posts_about_generic_code_sharing"> Blog posts about generic code sharing </span></h1>
<ul><li> <a href="http://schani.wordpress.com/2007/09/22/generics-sharing-in-mono/" class="external text" rel="nofollow">September 2007: Generics Sharing in Mono</a>
</li><li> <a href="http://schani.wordpress.com/2007/10/12/the-trouble-with-shared-generics/" class="external text" rel="nofollow">October 2007: The Trouble with Shared Generics</a>
</li><li> <a href="http://schani.wordpress.com/2007/10/15/a-quick-generics-sharing-update/" class="external text" rel="nofollow">October 2007: A Quick Generics Sharing Update</a>
</li><li> <a href="http://schani.wordpress.com/2008/01/29/other-types/" class="external text" rel="nofollow">January 2008: Other Types</a>
</li><li> <a href="http://schani.wordpress.com/2008/02/25/generic-types-are-lazy/" class="external text" rel="nofollow">February 2008: Generic Types Are Lazy</a>
</li><li> <a href="http://schani.wordpress.com/2008/03/10/sharing-static-methods/" class="external text" rel="nofollow">March 2008: Sharing Static Methods</a>
</li><li> <a href="http://schani.wordpress.com/2008/04/22/sharing-everything-and-saving-memory/" class="external text" rel="nofollow">April 2008: Sharing Everything And Saving Memory</a>
</li><li> <a href="http://schani.wordpress.com/2008/06/02/sharing-generic-methods/" class="external text" rel="nofollow">June 2008: Sharing Generic Methods</a>
</li><li> <a href="http://schani.wordpress.com/2008/06/27/another-generic-sharing-update/" class="external text" rel="nofollow">June 2008: Another Generic Sharing Update</a>
</li></ul>

