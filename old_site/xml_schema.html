---
layout: obsolete
title: "XML Schema"
permalink: /old_site/XML_Schema/
---

<h1>XML Schema</h1>

<p>Programming with XML Schema, by Atsushi Enomoto
</p><p>XML Schema is one kind of the "schema language" such as DTD, RELAX NG, Schematron and so on. XML Schema is useful for "typed XML programming" with less expressiveness than Schematron or RELAX NG (or even DTD in a sense). XML Schema is one of the W3C Recommendation. 
</p><p>There are three parts of the specification: <a href="http://www.w3.org/TR/xmlschema-0/" class="external text" rel="nofollow">primer</a> , <a href="http://www.w3.org/TR/xmlschema-1/" class="external text" rel="nofollow">structures</a> and <a href="http://www.w3.org/TR/xmlschema-2/" class="external text" rel="nofollow">datatypes</a> . 
</p>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Using_XML_Schema_with_System.Xml"><span class="tocnumber">1</span> <span class="toctext">Using XML Schema with System.Xml</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Using_XmlSchema_and_XmlSchemaCollection"><span class="tocnumber">2</span> <span class="toctext">Using XmlSchema and XmlSchemaCollection</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Reading.2C_Writing_and_Compiling_XmlSchema"><span class="tocnumber">2.1</span> <span class="toctext">Reading, Writing and Compiling XmlSchema</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#XmlSchemaCollection"><span class="tocnumber">2.2</span> <span class="toctext">XmlSchemaCollection</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#Validating_XML_using_XML_Schema"><span class="tocnumber">3</span> <span class="toctext">Validating XML using XML Schema</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#General_Purpose_Use"><span class="tocnumber">3.1</span> <span class="toctext">General Purpose Use</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Handling_Validation_Errors"><span class="tocnumber">3.2</span> <span class="toctext">Handling Validation Errors</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h1> <span class="mw-headline" id="Using_XML_Schema_with_System.Xml"> Using XML Schema with System.Xml </span></h1>
<p>In System.XML.dll, it is System.Xml.Schema namespace that holds the classes for XML Schema. In that namespace, most of them represents XML Schema element types. For example, XmlSchemaElement represents "xs:element" and XmlSchemaChoice means "xs:choice" (here the prefix "xs" is used as mapped to "<a href="http://www.w3.org/2001/XMLSchema" class="external free" rel="nofollow">http://www.w3.org/2001/XMLSchema</a>" namespace URI). 
</p><p>There are several areas in which XML Schema is used: 
</p>
<ul><li>Validation - We can use XmlValidatingReader to validate XML document against a set of schemas.  
</li><li>CLR type mapping - We can use xsd.exe to export CLR Types from XML Schemas.  
</li><li>Data column mapping - We can infer DataSet columns and relations from XML Schemas (it is not fully supported yet).  
</li></ul>
<p>Moreover, note that Web service functionality is heavily dependent on the CLR type mapping. 
</p>
<h1> <span class="mw-headline" id="Using_XmlSchema_and_XmlSchemaCollection"> Using XmlSchema and XmlSchemaCollection </span></h1>
<h2> <span class="mw-headline" id="Reading.2C_Writing_and_Compiling_XmlSchema"> Reading, Writing and Compiling XmlSchema </span></h2>
<p>In this section, the primary class is XmlSchema (System.Xml.Schema.XmlSchema). With this class, you can read and write an XML schema document for one namespace, using Read() and Write() methods. 
</p><p>(You can use XmlSerializer to read and write XmlSchema, but it is not recommended to use deserialization. Firstly, it does not support LineNumber, LinePosition and SourceUri. Secondly, it brings some namespace scoping problems in identity constraints i.e. XmlSchemaXPath when any prefixes are specified in the "xpath" attributes.) 
</p><p>After reading a schema into XmlSchema, you will have to call Compile() to check if the schema is really valid. Since you can build a schema structure manually, it might be invalid during the read and build process. Once you called Compile(), the Post Schema Compilation Information is set, and it is used for actual validation, type mapping, and so on. 
</p><p>However, note that usually you don't have to call Compile() by yourself. As described below, when you use XmlSchemaCollection, it will automatically compile the schema you would add. 
</p>
<h2> <span class="mw-headline" id="XmlSchemaCollection"> XmlSchemaCollection </span></h2>
<p>By the way, XML Schema is designed as to handle one or more namespaces. How about multiple namespaces? XmlSchemaCollection class represents a collection of schemas. (In the forthcoming version of .NET 1.2, it will have the similar class named XmlSchemaSet, that is more conformant to W3C standard. 
</p><p>To add a schema to the collection, use Add() method. When you add a schema, the schema is compiled using Compile() if it is not compiled yet. 
</p><p><br />
</p>
<h1> <span class="mw-headline" id="Validating_XML_using_XML_Schema"> Validating XML using XML Schema </span></h1>
<h2> <span class="mw-headline" id="General_Purpose_Use"> General Purpose Use </span></h2>
<p>In the sections above, I described how XML Schema documents can be read into XmlSchema and XmlSchemaCollection classes. Now, it is time to "use" these classes. Firstly this section describes how to validate XML instances against XML Schema. 
</p><p>XML Schema validation is done by XmlValidatingReader. It supports DTD validation and XML Schema validation. 
</p><p>XmlValidatingReader instance can be created from an XmlReader. Note that Microsoft .NET Framework supports only XmlTextReader as its input. Mono can handle any XmlReader. 
</p><p>To specify schemas, use Add() method of the Schemas property (that is type of XmlSchemaCollection). 
</p>
<h2> <span class="mw-headline" id="Handling_Validation_Errors"> Handling Validation Errors </span></h2>
<p>Since XmlValidatingReader is represented as to handle many kinds of validation feature, it might be useless when you both have DTD and XML schema (e.g. DTD for entities and XML Schema for document structures). 
</p><p>Another use case is ignoring errors, when you just wanted to add Post Schema Validation Infoset to the document. (However, it is not highly recommended to depend on PSVI, since when you use it the document will become useless against other schemas anymore. That's the primary reason why RELAX NG is specified.) 
</p><p>In such cases, you can specify ValidationType property (type of ValidationType) as DTD, Schema, or None. When you specify "None", no validation errors are thrown. 
</p><p>You can also use ValidationEventHandler event (of type ValidationEventHandler delegate) to catch validation error manually. When you specified it, it also never throws any validation errors unless you rethrow the error in the delegated method.
</p>
