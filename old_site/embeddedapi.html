---
layout: obsolete
title: "Embedded-api"
permalink: /old_site/Embedded-api/
redirect_from:
  - /Embedded-api/
---

<h1>Embedded-api</h1>

<p><br />
</p>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Embedding_Mono"><span class="tocnumber">1</span> <span class="toctext">Embedding Mono</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Embedding_the_Mono_runtime.2C_preliminary_version"><span class="tocnumber">1.1</span> <span class="toctext">Embedding the Mono runtime, preliminary version</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Embedding_the_runtime"><span class="tocnumber">1.2</span> <span class="toctext">Embedding the runtime</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Exposing_C_code_to_the_CIL_universe"><span class="tocnumber">1.3</span> <span class="toctext">Exposing C code to the CIL universe</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Invoking_Methods_in_the_CIL_universe"><span class="tocnumber">1.4</span> <span class="toctext">Invoking Methods in the CIL universe</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Samples"><span class="tocnumber">1.5</span> <span class="toctext">Samples</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h1> <span class="mw-headline" id="Embedding_Mono"> Embedding Mono </span></h1>
<ul><li> Embedding the Mono runtime, preliminary version
</li></ul>
<p><br />
</p>
<ul><li> Embedding the runtime
</li></ul>
<p><br />
</p>
<ul><li> Exposing C code to the CIL universe
</li></ul>
<p><br />
</p>
<ul><li> Invoking Methods in the CIL universe
</li></ul>
<p><br />
</p>
<ul><li> Samples
</li></ul>
<p><br />
</p>
<h2> <span class="mw-headline" id="Embedding_the_Mono_runtime.2C_preliminary_version"> Embedding the Mono runtime, preliminary version </span></h2>
<p>This document describes how to embed the Mono runtime in your
application, and how to invoke CIL methods from C, and how to
invoke C code from CIL
</p><p>Slides for Paolo's presentation at .NET ONE on the embedding
API are available here: &lt;a
href="<a href="http://primates.ximian.com/~lupus/slides/embed" class="external free" rel="nofollow">http://primates.ximian.com/~lupus/slides/embed</a>"&gt;Hosting the Mono
Runtime&lt;/a&gt;. You can also get his &lt;a
href="<a href="http://primates.ximian.com/~lupus/slides/embed/Mono-0.01.tar.gz" class="external free" rel="nofollow">http://primates.ximian.com/~lupus/slides/embed/Mono-0.01.tar.gz</a>"&gt;sample
Mono module for Perl&lt;/a&gt;
</p><p>Authors: Paolo Molaro, Miguel de Icaza.
</p>
<h2> <span class="mw-headline" id="Embedding_the_runtime"> Embedding the runtime </span></h2>
<p>Embedding the runtime consists of various steps: 
</p><p><br />
</p>
<ul><li> Compiling and linking the Mono runtime
</li></ul>
<p><br />
</p>
<ul><li> Initializing the Mono runtime
</li></ul>
<p><br />
</p>
<ul><li> Optionally expose C code to the C#/CIL universe.
</li></ul>
<p><br />
These are discussed in detail next.
</p><p><b>Compiling and Linking</b>
</p><p>To embed the runtime, you have to link your code against the
Mono runtime libraries. To do this, you want to pass the
flags returned by pkg-config to your compiler:
</p>
<pre>

pkg-config --cflags --libs mono
</pre>
<p><br />
Like this:
</p>
<pre>

gcc sample.c `pkg-config --cflags --libs mono`
</pre>
<p><br />
You can separate the compilation flags from the linking flags, for
instance, you can use the following macros in your makefile:
</p>
<pre>

CFLAGS=`pkg-config --cflags mono`
LDFLAGS=`pkg-config --libs mono`
</pre>
<p><br />
<b>Initializing the Mono runtime</b>
</p><p>To initialize the runtime, call mono_jit_init, like this:
</p>
<pre>

MonoDomain 
*domain;
domain = mono_jit_init (&quot;domain-name&quot;);
</pre>
<p><br />
That will return a MonoDomain where your code will be
executed. You can create multiple domains. Each domain is
isolated from the other domains and code in one domain will
not interfere with code in other domains. This is useful if
you want to host different applications in your program.
</p><p>Now, it is necessary to transfer control to Mono, and setup
the threading infrastructure, you do this like this:
</p>
<pre>

void 
*user_data = NULL;
mono_runtime_exec_managed_code (domain, main_thread_handler, user_data);
</pre>
<p><br />
Where your main_thread_handler can load your assembly and execute it:
</p>
<pre>

static void main_thread_handler (gpointer user_data)
{
MonoAssembly 
*assembly;
assembly = mono_domain_assembly_open (domain, &quot;file.dll&quot;);
if (!assembly)
error ();
</pre>
<p><br />
In the above example, the contents of `file.dll' will be
loaded into the domain. This only loads the code, but it will
not execute anything yet. You can replace `file.dll' with
another transport file, like `file.exe'
</p><p>To start executing code, you must invoke a method in the
assembly, or if you have provided a static Main method (an
entry point), you can use the convenience function:
</p>
<pre>

retval = mono_jit_exec (domain, assembly, argc - 1, argv + 1);
</pre>
<p><br />
If you want to invoke a different method, look at the
`Invoking Methods in the CIL universe' section later on.
</p><p><b>Shutting down the runtime</b>
</p><p>To shutdown the Mono runtime, you have to clean up all the
domains that were created, use this function:
</p>
<pre>

mono_jit_cleanup (domain);
</pre>
<p><br />
<b>Applications that use threads.</b>
</p><p>The Boehm GC system needs to catch your calls to the pthreads
layer, so in each file where you use pthread.h you should
include the &lt;gc/gc.h&gt; file. 
</p><p>If you can not do this for any reasons, just remember that you
can not store pointers to Mono Objects on the stack, you can
store them safely in the heap, or in global variables though
</p>
<h2> <span class="mw-headline" id="Exposing_C_code_to_the_CIL_universe"> Exposing C code to the CIL universe </span></h2>
<p>The Mono runtime provides two mechanisms to expose C code to
the CIL universe: internal calls and native C code. Internal
calls are tightly integrated with the runtime, and have the
least overhead, as they use the same data types that the
runtime uses.
</p><p>The other option is to use the Platform Invoke (P/Invoke) to
call C code from the CIL universe, using the standard P/Invoke
mechanisms.
</p><p>To register an internal call, use this call in the C code:
</p>
<pre>

mono_add_internal_call (&quot;Hello::Sample&quot;, sample);
</pre>
<p><br />
Now, you need to declare this on the C# side:
</p>
<pre>

using System;
using System.Runtime.CompilerServices;
</pre>
<pre>

class Hello {
[MethodImplAttribute(MethodImplOptions.InternalCall)]
extern static string Sample ();
}
</pre>
<p><br />
Since this routine returns a string, here is the C definition:
</p>
<pre>

static MonoString
*
Sample ()
{
return mono_string_new (mono_domain_get (), &quot;Hello!&quot;);
}
</pre>
<p><br />
Notice that we have to return a `MonoString', and we use the
`mono_string_new' API call to obtain this from a string.
</p>
<h2> <span class="mw-headline" id="Invoking_Methods_in_the_CIL_universe"> Invoking Methods in the CIL universe </span></h2>
<p>Calling a method in the CIL universe from C requires a number of steps:
</p><p><br />
</p>
<ul><li> Obtaining the MonoMethod handle to the method.
</li></ul>
<p><br />
</p>
<ul><li> The method invocation.
</li></ul>
<p><br />
<b>Obtaining a MonoMethod</b>
</p><p>To get a MonoMethod there are several ways.
</p><p>You can get a MonoClass (the structure representing a type)
using [[|mono_class_from_name]]
</p><p>and then loop in the returned class method array until you get
the one you're looking for. There are examples of such
searches as static functions in several C files in
metadata/
</p>
<ul><li>.c: we need to expose one through the API and remove
</li></ul>
<p>the duplicates.
</p><p>The other, simpler, way is to use the functions in
debug-helpers.h: there are examples of their use in monograph,
mint and the jit as well. You basically use a string
description of the method, like:
</p>
<pre>

&quot;System.Object:GetHashCode()&quot;
</pre>
<p><br />
and create a MonoMethodDesc out of it with [[|mono_method_desc_new]]
</p><p>You can then use [[|these methods]] to search for the
method in a class or in an image. You would
typically do this just once at the start of the program and
store the result for reuse somewhere.
</p><p><b>Invoking a Method</b>
</p><p>There are two functions to call a managed method:
</p>
<pre>

MonoObject
*
mono_runtime_invoke (MonoMethod 
*method, void 
*obj,
void 
*
*params,
MonoObject 
*
*exc);
and
MonoObject
*
mono_runtime_invoke_array (MonoMethod 
*method, void 
*obj,
MonoArray 
*params,
MonoObject 
*
*exc);
</pre>
<p><br />
obj is the 'this' pointer, it should be NULL for static
methods, a MonoObject
</p>
<ul><li> for object instances and a pointer to
</li></ul>
<p>the value type for value types.
</p><p>The params array contains the arguments to the method with the
same convention: MonoObject
</p>
<ul><li> pointers for object instances and
</li></ul>
<p>pointers to the value type otherwise. The _invoke_array
variant takes a C# object[] as the params argument (MonoArray
</p>
<ul><li>params): in this case the value types are boxed inside the
</li></ul>
<p>respective reference representation.
</p><p><br />
From unmanaged code you'll usually use the
mono_runtime_invoke() variant.
Note that this function doesn't handle virtual methods for
you, it will exec the exact method you pass: we still need to
expose a function to lookup the derived class implementation
of a virtual method (there are examples of this in the code,
though).
</p><p>You can pass NULL as the exc argument if you don't want to
catch exceptions, otherwise, 
</p>
<ul><li>exc will be set to the exception
</li></ul>
<p>thrown, if any. if an exception is thrown, you can't use the
MonoObject
</p>
<ul><li> result from the function.
</li></ul>
<p>If the method returns a value type, it is boxed in an object
reference.
We have plans for providing an additional method that returns
an unmanaged-&gt;managed thunk like this:
</p>
<pre>

void
* mono_method_get_unmanaged_thunk (MonoMethod 
*method);
</pre>
<p><br />
You'll be able to store the returned pointer in a function
pointer with the proper signature and
[[|call that directly from C:]]
</p><p>It may not be possible to manage exceptions in that case,
though. I need to think more about it.
</p><p><b>Threading issues</b>
</p><p>If your application creates threads on its own, and you want them to
be able to call code into the CIL universe with Mono, you have to
register the thread with Mono before issuing the call.
</p><p>To do so, call the mono_thread_attach() function before you execute
any managed code from the thread
</p>
<h2> <span class="mw-headline" id="Samples"> Samples </span></h2>
<p>See the sample programs in mono/sample/embed for examples of embedding the Mono runtime in your application.
</p>
