---
layout: obsolete
title: "Gcc4cil"
permalink: /old_site/Gcc4cil/
---

<h1>Gcc4cil</h1>

<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#The_gcc4cil_project"><span class="tocnumber">1</span> <span class="toctext">The gcc4cil project</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#The_gcc4cil_linker"><span class="tocnumber">2</span> <span class="toctext">The gcc4cil linker</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#What_the_linker_adds_to_the_merge_tool"><span class="tocnumber">2.1</span> <span class="toctext">What the linker adds to the merge tool</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#How_the_linker_handles_external_symbols"><span class="tocnumber">2.2</span> <span class="toctext">How the linker handles external symbols</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h1> <span class="mw-headline" id="The_gcc4cil_project"> The gcc4cil project </span></h1>
<p>A team in a research lab at [<a href="http://www.st.com" class="external text" rel="nofollow">ST Microelectronics</a>] added a CIL
backend to gcc (incidentally, they published their results in the same summer in
which a Google SOC [<a href="http://mono-project.com/Summer2006#GCC_CIL_Backend" class="external text" rel="nofollow">project</a>]
was attempting the same thing).
</p><p>The project has then been accepted as an official gcc branch, so the code lives
in the gcc repository ("svn co <a href="svn://gcc.gnu.org/svn/gcc/branches/st/cli" class="external free" rel="nofollow">svn://gcc.gnu.org/svn/gcc/branches/st/cli</a>").
</p><p>A key point of gcc4cil is that it is only a <i>compiler</i>: it provides no standard
C library, neitner it makes your life easy if you want to use other external C
libraries in binary form.
</p><p>To solve the "C library" problem, there are two possible approches:
</p>
<ol><li> provide a managed implementation of it, or
</li><li> let the generated code use the native C library in the underlying system.
</li></ol>
<p>Approach 1 has the following disadvantages:
</p>
<ul><li> it takes a <i>lot</i> of work to properly reimplement a complete C standard library, and
</li><li> if the compiled program interacts also with other native libraries (each non trivial program does so), it is a nightmare to assure ABI compatibility between the managed C standard library and the native ones (think passing "FILE*" streams around...).
</li></ul>
<p>So, even if (to be fair) there are also advantages in approach 1, we decide to support
approach 2. In doing so, we handle the standard C library as any other native library,
and instrument the CIL code generated by gcc so that it p/invokes into the correct lib.
</p><p>This instrumentation is done in the linking stage.
</p>
<h1> <span class="mw-headline" id="The_gcc4cil_linker"> The gcc4cil linker </span></h1>
<p>The gcc4cil compilation pipeline is just the gcc one; this means that gcc4cil produces
one "assembler" file (in IL syntax) for each C source file, separately compiles each
file using "ilasm", and then needs to link them.
</p><p>This linking step, in the approach 2 described above, has two goals:
</p>
<ul><li> resolve managed symbols (symbols defined in other C source files in the current program), and
</li><li> link to unmanaged symbols implemented in native libraries (so thet the standard C library is just "yet another library" in the linking stage).
</li></ul>
<p>The linker is based on <a href="{{site.baseurl}}/Cecil" title="Cecil">Cecil</a>.
We had a prototype implementation from Wang Yi (done during Google SOC 2006), but the
current implementation (by Massimiliaho Mantione) is based on the Cecil
"merge" tool by Alex Prudkiy, and lives
in the Cecil svn module under the "gcc4cil" directory.
The rationale for reusing the merge tool is that, even if most of the work of the linker
when it operates on files generated by the current gcc4cil is highly specialized and
has little to do with merging general .NET assemblies. It could happen in the future
that gcc4cil will support extensions to produce "proper" .net classes. At that point
the linker should evolve into a generalized merge tool, like the one in the Cecil source
tree.
Since we already have such a tool, and its functionality already partially overlaps
with the linker needs, extending it is the way to go.
</p>
<h2> <span class="mw-headline" id="What_the_linker_adds_to_the_merge_tool"> What the linker adds to the merge tool </span></h2>
<p>While merging the assemblies generated by gcc4cil, the linker has these additional
tasks:
</p>
<ul><li> Keep a symbol table of all <i>internal</i> symbols (global variables and functions generated by gcc4cil which can be referenced from assemblies that participate in the linking process). These are simply collected during the first pass of the merge tool.
</li><li> Keep a table of all <i>external</i> symbols (all the accessible symbols in the native libraries involved in the linking). These are collected upfront, calling "nm -D" on each library.
</li><li> Actually modify the code so that is uses the proper symbols. When gcc4cil compiler refers to a symbol that the linker will have to resolve, it pretends the symbol belongs to a fictious "ExternalAssembly" assembly. Therefore, the linker has two tasks:
<ul><li> discard all the memberrefs referring to "ExternalAssembly" (the members will be directly contained in the produced assembly), and
</li><li> modify the CIL code so that it refers to the proper members (this is the actual "relolve" phase in the linker), which in turn can be
<ul><li> in the internal symbol table, or
</li><li> in the external one.
</li></ul>
</li></ul>
</li></ul>
<p>Of course, every symbol belonging to the fictious "ExternalAssembly" and not found in any of the symbol tables will result in a linker error.
</p>
<h2> <span class="mw-headline" id="How_the_linker_handles_external_symbols"> How the linker handles external symbols </span></h2>
<p>Symbols that are functions (seen as static methods) are converted to the appropriate
p/invoke call to the external function.
</p><p>For symbols that are global variables we are still building a solution.
</p>
