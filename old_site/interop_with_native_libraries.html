---
layout: obsolete
title: "Interop with Native Libraries"
permalink: /old_site/Interop_with_Native_Libraries/
---

<h1>Interop with Native Libraries</h1>

<p>Everything you (n)ever wanted to know about marshaling (and were afraid to ask!)
</p><p>By Jonathan Pryor
Contributions:
Hisham Mardam Bey
</p>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Library_Handling"><span class="tocnumber">2</span> <span class="toctext">Library Handling</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Windows_DLL_Search_Path"><span class="tocnumber">2.1</span> <span class="toctext">Windows DLL Search Path</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Linux_Shared_Library_Search_Path"><span class="tocnumber">2.2</span> <span class="toctext">Linux Shared Library Search Path</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Mac_OS_X_Framework_and_.dylib_Search_Path"><span class="tocnumber">2.3</span> <span class="toctext">Mac OS X Framework and .dylib Search Path</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Library_Names"><span class="tocnumber">2.4</span> <span class="toctext">Library Names</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#Invoking_Unmanaged_Code"><span class="tocnumber">3</span> <span class="toctext">Invoking Unmanaged Code</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Runtime_Exception_Propagation"><span class="tocnumber">3.1</span> <span class="toctext">Runtime Exception Propagation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#Marshaling"><span class="tocnumber">4</span> <span class="toctext">Marshaling</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="#Memory_Boundaries"><span class="tocnumber">4.1</span> <span class="toctext">Memory Boundaries</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Blittable_Types"><span class="tocnumber">4.2</span> <span class="toctext">Blittable Types</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Strings"><span class="tocnumber">4.3</span> <span class="toctext">Strings</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="#More_Control"><span class="tocnumber">4.3.1</span> <span class="toctext">More Control</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#Passing_Caller-Modifiable_Strings"><span class="tocnumber">4.3.2</span> <span class="toctext">Passing Caller-Modifiable Strings</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Strings_as_Return_Values"><span class="tocnumber">4.3.3</span> <span class="toctext">Strings as Return Values</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="#Class_and_Structure_Marshaling"><span class="tocnumber">4.4</span> <span class="toctext">Class and Structure Marshaling</span></a>
<ul>
<li class="toclevel-3 tocsection-17"><a href="#Class_Marshaling"><span class="tocnumber">4.4.1</span> <span class="toctext">Class Marshaling</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="#Structure_Marshaling"><span class="tocnumber">4.4.2</span> <span class="toctext">Structure Marshaling</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#Classes_and_Structures_as_Return_Values"><span class="tocnumber">4.4.3</span> <span class="toctext">Classes and Structures as Return Values</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#Memory_Management"><span class="tocnumber">4.4.4</span> <span class="toctext">Memory Management</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="#Choosing_between_Classes_and_Structures"><span class="tocnumber">4.4.5</span> <span class="toctext">Choosing between Classes and Structures</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-22"><a href="#Summary"><span class="tocnumber">4.5</span> <span class="toctext">Summary</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#Marshaling_Class_and_Structure_Members"><span class="tocnumber">4.6</span> <span class="toctext">Marshaling Class and Structure Members</span></a>
<ul>
<li class="toclevel-3 tocsection-24"><a href="#Boolean_Members"><span class="tocnumber">4.6.1</span> <span class="toctext">Boolean Members</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="#Unions"><span class="tocnumber">4.6.2</span> <span class="toctext">Unions</span></a></li>
<li class="toclevel-3 tocsection-26"><a href="#Longs"><span class="tocnumber">4.6.3</span> <span class="toctext">Longs</span></a></li>
<li class="toclevel-3 tocsection-27"><a href="#Arrays_Embedded_Within_Structures"><span class="tocnumber">4.6.4</span> <span class="toctext">Arrays Embedded Within Structures</span></a>
<ul>
<li class="toclevel-4 tocsection-28"><a href="#C.23_2.0_Functionality"><span class="tocnumber">4.6.4.1</span> <span class="toctext">C# 2.0 Functionality</span></a></li>
<li class="toclevel-4 tocsection-29"><a href="#Real_World_Experience"><span class="tocnumber">4.6.4.2</span> <span class="toctext">Real World Experience</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-30"><a href="#Summary_2"><span class="tocnumber">4.6.5</span> <span class="toctext">Summary</span></a></li>
<li class="toclevel-3 tocsection-31"><a href="#A_Warning_about_FieldOffset"><span class="tocnumber">4.6.6</span> <span class="toctext">A Warning about FieldOffset</span></a></li>
<li class="toclevel-3 tocsection-32"><a href="#Marshaling_Pointers"><span class="tocnumber">4.6.7</span> <span class="toctext">Marshaling Pointers</span></a>
<ul>
<li class="toclevel-4 tocsection-33"><a href="#Marshaling_Embedded_Strings"><span class="tocnumber">4.6.7.1</span> <span class="toctext">Marshaling Embedded Strings</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-34"><a href="#Custom_Marshaling"><span class="tocnumber">4.7</span> <span class="toctext">Custom Marshaling</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#Manual_Marshaling"><span class="tocnumber">4.8</span> <span class="toctext">Manual Marshaling</span></a>
<ul>
<li class="toclevel-3 tocsection-36"><a href="#Marshaling_char.2A.2A"><span class="tocnumber">4.8.1</span> <span class="toctext">Marshaling char**</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-37"><a href="#Avoiding_Marshaling"><span class="tocnumber">5</span> <span class="toctext">Avoiding Marshaling</span></a>
<ul>
<li class="toclevel-2 tocsection-38"><a href="#GC-Safe_P.2FInvoke_code"><span class="tocnumber">5.1</span> <span class="toctext">GC-Safe P/Invoke code</span></a>
<ul>
<li class="toclevel-3 tocsection-39"><a href="#.NET_2.0_and_SafeHandles"><span class="tocnumber">5.1.1</span> <span class="toctext">.NET 2.0 and SafeHandles</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-40"><a href="#Properly_Disposing_of_Resources"><span class="tocnumber">5.2</span> <span class="toctext">Properly Disposing of Resources</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-41"><a href="#Miscellaneous_Topics"><span class="tocnumber">6</span> <span class="toctext">Miscellaneous Topics</span></a>
<ul>
<li class="toclevel-2 tocsection-42"><a href="#Meaning_of_.22Unsafe.22"><span class="tocnumber">6.1</span> <span class="toctext">Meaning of "Unsafe"</span></a></li>
<li class="toclevel-2 tocsection-43"><a href="#Security"><span class="tocnumber">6.2</span> <span class="toctext">Security</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-44"><a href="#Troubleshooting"><span class="tocnumber">7</span> <span class="toctext">Troubleshooting</span></a></li>
<li class="toclevel-1 tocsection-45"><a href="#Commentary"><span class="tocnumber">8</span> <span class="toctext">Commentary</span></a>
<ul>
<li class="toclevel-2 tocsection-46"><a href="#P.2FInvoke_Specification"><span class="tocnumber">8.1</span> <span class="toctext">P/Invoke Specification</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-47"><a href="#Thanks"><span class="tocnumber">9</span> <span class="toctext">Thanks</span></a></li>
<li class="toclevel-1 tocsection-48"><a href="#Copyright"><span class="tocnumber">10</span> <span class="toctext">Copyright</span></a></li>
<li class="toclevel-1 tocsection-49"><a href="#Revision_History"><span class="tocnumber">11</span> <span class="toctext">Revision History</span></a></li>
</ul>
</td></tr></table>
<h1> <span class="mw-headline" id="Introduction"> Introduction </span></h1>
<p>The <a href="http://www.ecma-international.org/publications/standards/ecma-335.htm" class="external text" rel="nofollow">Common Language Infrastructure</a> (CLI) is designed to make it "easy" to interoperate with existing code. In principal, all you need to do is create a [http:/monodoc/T:System.Runtime.InteropServices.DllImportAttribute DllImport] function declaration for the existing code to invoke, and the runtime will handle the rest. For example: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;libc.so&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
 <span style="color: #0600FF; font-weight: bold;">private</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">int</span> getpid <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<p>Please note that most of the classes and enumerations mentioned in this document reside in the [http:/monodoc/N:System.Runtime.InteropServices System.Runtime.InteropServices] namespace. 
</p><p>The above C# function declaration would invoke the POSIX <b>getpid </b>(2) system call on platforms that have the <tt>libc.so</tt> library.  If  <tt>libc.so</tt> exists but doesn't have the <b>getpid</b> export, an [http:/monodoc/T:System.EntryPointNotFoundException EntryPointNotFoundException] exception is thrown.  If <tt>libc.so</tt> can't be loaded, a [http:/monodoc/T:System.DllNotFoundException DllNotFoundException] exception is thrown.  Simple. Straightforward. What could be easier? 
</p><p>There are three problems with this:
</p>
<ol><li> <a href="#Library_Handling">Specifying the library in the DllImport statement</a>.
</li><li> <a href="#Invoking_Unmanaged_Code">Determining what function to actually invoke</a>.
</li><li> <a href="#Marshaling">Passing parameters</a>; most existing code is far more complex. Strings will need to be passed, structures may need to be passed, memory management practices will become involved...
</li></ol>
<p>Existing code is a complex beast, and the interop layer needs to support this complexity.
</p>
<h1> <span class="mw-headline" id="Library_Handling"> Library Handling </span></h1>
<p>How does the runtime find the library specified in the <b>DllImport</b> attribute? This question is inherently platform specific. 
</p>
<h2> <span class="mw-headline" id="Windows_DLL_Search_Path"> Windows DLL Search Path </span></h2>
<p>From the MSDN LoadLibrary documentation, the DLLs needed by the program are searched for in the following order: 
</p>
<ol><li>The directory from which the application loaded.  
</li><li>The current directory  
</li><li>The system directory. Use the <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/sysinfo/base/getsystemdirectory.asp" class="external text" rel="nofollow">GetSystemDirectory()</a> function to get the path of this directory.  
</li><li>The 16-bit system directory.
</li><li>The Windows directory. Use the <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/sysinfo/base/getsystemdirectory.asp" class="external text" rel="nofollow">GetWindowsDirectory()</a> function to get the path of this directory.  
</li><li>The directories that are listed in the <tt>PATH</tt> environment variable.  
</li></ol>
<p>Of course, reality isn't quite that simple. In practice, the "system" directory is actually <tt>%WINDIR%\system32</tt>, except on Windows 9x platforms where it's <tt>%WINDIR%\system</tt>. The 16-bit system directory is typically <tt>%WINDIR%\system</tt>, but isn't recognized as a separate search directory on Windows 9x platforms. 
</p><p>Furthermore, on Windows Server 2003 and Windows XP SP1, the registry entry <tt>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode</tt> alters the above ordering. If this is <tt>1</tt> (the default), then the current directory is searched after the system and Windows directories. This is a security feature (it prevents a trojan library from being loaded instead of, for example, <tt>OLE32.DLL</tt>), but it turns the above list into: 1, 3, 4, 5, 2, 6. 
</p><p>See also: <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/loadlibrary.asp" class="external text" rel="nofollow">LoadLibrary() Documentation at MSDN</a>
</p>
<h2> <span class="mw-headline" id="Linux_Shared_Library_Search_Path"> Linux Shared Library Search Path </span></h2>
<p>From the <b>dlopen</b>(3) man page, the necessary shared libraries needed by the program are searched for in the following order: 
</p>
<ol><li>A colon-separated list of directories in the user's <tt>LD_LIBRARY_PATH</tt> environment variable. This is a frequently-used way to allow native shared libraries to be found by a CLI program.  
</li><li>The list of libraries cached in <tt>/etc/ld.so.cache</tt>. <tt>/etc/ld.so.cache</tt> is created by editing <tt>/etc/ld.so.conf</tt> and running <b>ldconfig</b>(8). Editing <tt>/etc/ld.so.conf</tt> is the preferred way to search additional directories, as opposed to using <tt>LD_LIBRARY_PATH</tt>, as this is more secure (it's more difficult to get a trojan library into <tt>/etc/ld.so.cache</tt> than it is to insert it into <tt>LD_LIBRARY_PATH</tt>).  
</li><li><tt>/lib</tt>, followed by <tt>/usr/lib</tt>.  
</li></ol>
<p>As a Mono extension, if the library being loaded is <tt>__Internal</tt>, then the main program is searched for method symbols. This is equivalent to calling <b>dlopen</b>(3) with a <i>filename</i> of <tt>NULL</tt>. This allows you to P/Invoke methods that are within an application that is embedding Mono.
</p><p>See also: the <b>dlopen</b>(3) man page, the <b>ld.so</b>(8) man page, <a href="http://www-106.ibm.com/developerworks/linux/library/l-shlibs.html?ca=dgr-lnxw07SharedLib" class="external text" rel="nofollow">Dissecting shared libraries</a>.
</p>
<h2> <span class="mw-headline" id="Mac_OS_X_Framework_and_.dylib_Search_Path"> Mac OS X Framework and .dylib Search Path </span></h2>
<p>The Framework and library search path is: 
</p>
<ol><li>A colon-separated list of directories in the user's <tt>DYLD_FRAMEWORK_PATH</tt> environment variable.  
</li><li>A colon-separated list of directories in the user's <tt>DYLD_LIBRARY_PATH</tt> environment variable.  
</li><li>A colon-separated list of directories in the user's <tt>DYLD_FALLBACK_FRAMEWORK_PATH</tt> environment variable, which defaults to the directories: 
<ul><li><tt>~/Library/Frameworks</tt>
</li><li><tt>/Library/Frameworks</tt>
</li><li><tt>/Network/Library/Frameworks</tt>
</li><li><tt>/System/Library/Frameworks</tt>
</li></ul>
</li><li>A colon-separated list of directories in the user's <tt>DYLD_FALLBACK_LIBRARY_PATH</tt> environment variable, which defaults to the directories:
<ul><li><tt>~/lib</tt>
</li><li><tt>/usr/local/lib</tt>
</li><li><tt>/lib</tt>
</li><li><tt>/usr/lib</tt>
</li></ul>
</li></ol>
<p>Note: Mono uses GLib to load libraries, and GLib has a bug on Mac OS X where it doesn't use a <tt>.dylib</tt> extension, but instead uses the Unix <tt>.so</tt> extension.  While this should eventually be fixed, the current workaround is to <a href="#Library_Names">write a <tt>.config</tt> file which maps to the <tt>.dylib</tt> file</a>, e.g.
</p>
<pre class="xml" style="font-family:monospace;"> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;configuration<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>
   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;dllmap</span> <span style="color: #000066;">dll</span>=<span style="color: #ff0000;">&quot;mylib&quot;</span> <span style="color: #000066;">target</span>=<span style="color: #ff0000;">&quot;mylib.dylib&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span>
 <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/configuration<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre>
<p>TODO: Will mono support both frameworks and dylibs? 
</p><p>See also: <a href="http://developer.apple.com/documentation/MacOSX/Conceptual/SystemOverview/Frameworks/chapter_7_section_2.html" class="external text" rel="nofollow">The Framework as a Library Package at Apple</a>, the <a href="http://www.hmug.org/man/1/dyld.html" class="external text" rel="nofollow">dyld(1) man page</a>
</p>
<h2> <span class="mw-headline" id="Library_Names"> Library Names </span></h2>
<p>Knowing where to look for the library is only half of the problem. Knowing what library to load is the other half. 
</p><p>Different platforms have different naming conventions. Windows platforms append <tt>.DLL</tt> to the library name, such as <tt>OLE32.DLL</tt>. Linux platforms use a <tt>lib</tt> prefix and a <tt>.so</tt> suffix<sup><a href="#lib-name-note">1</a></sup>. Mac OS X platforms have a <tt>lib</tt> prefix and a <tt>.dylib</tt> suffix, unless they're a Framework, in which case they're a directory and things get more complicated. 
</p>
<dl><dd> <span id="lib-name-note">Note 1</span>: Strictly speaking, Unix shared libraries are typically versioned, and the version number follows the <tt>.so</tt> suffix.  For example, <tt>libfreetype.so.6.3.3</tt> is a fully versioned library.  Versioning throws a "wrench" into the works, and is best dealt with through Mono's &lt;dllmap/&gt; mechanism; see below for details.
</dd></dl>
<p>If you have control over the library name, keep the above naming conventions in mind and don't use a platform-specific library name in the <b>DllImport</b> statement. Instead, just use the library name itself, without any prefixes or suffixes, and rely on the runtime to find the appropriate library at runtime. For example: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;MyLibrary&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
 <span style="color: #0600FF; font-weight: bold;">private</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> Frobnicate <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<p>Then, you just need to provide <tt>MyLibrary.dll</tt> for Windows platforms, <tt>libMyLibrary.so</tt> for Unix platforms, and <tt>libMyLibrary.dylib</tt> for Mac OS X platforms. 
</p>
<dl><dd> Note: Windows will not automatically append a <tt>.dll</tt> extension to library names that already have a period (.) in their name, such as <tt>libgtk-win32-2.0-0.dll</tt>.  If you try to use <tt>libgtk-win32-2.0-0</tt> as the library name, Windows won't automatically append <tt>.dll</tt>, resulting in  a <b>DllNotFoundException</b>.  Consequently you should either avoid periods in library names or always use the full filename (including the <tt>.dll</tt> extension) and rely on Mono's &lt;dllmap/&gt; mechanism.
</dd></dl>
<p>What if you don't have the same name across all platforms? For example, the GTK+ library name on Windows is <tt>libgtk-win32-2.0-0.dll</tt>, while the Unix equivalent library is <tt>libgtk-x11-2.0.so</tt>. How do you write portable Platform Invoke (P/Invoke) code that will work cross-platform? 
</p><p>The short answer is that you don't. There is no standard way of specifying platform-specific library names. 
</p><p>However, as an extension, Mono provides a library mapping mechanism. Two places are searched for library mappings: in the <tt>$prefix/etc/mono/config</tt> XML file, and in a per-assembly <tt>.config</tt> file, located in the same directory as the assembly. The .config file must be named like the assembly with ".config" as extension, e.g. <tt>MyAssembly.exe.config</tt> or <tt>MyAssembly.dll.config</tt>. These files contains <tt>&lt;dllmap/&gt;</tt> elements, which map an input library (the library specified in the <b>DllImport</b> statement) to the actual platform-specific library to load. For example: 
</p>
<pre class="xml" style="font-family:monospace;"> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;configuration<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>
    <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;dllmap</span> <span style="color: #000066;">dll</span>=<span style="color: #ff0000;">&quot;libgtk-win32-2.0-0.dll&quot;</span> <span style="color: #000066;">target</span>=<span style="color: #ff0000;">&quot;libgtk-x11-2.0.so&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span>
 <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/configuration<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre>
<p>Unlike .NET, Mono permits <tt>.DLL</tt> assemblies to have <tt>.config</tt> files, which are <i>only</i> used for this library mapping mechanism. 
</p><p>Using this mechanism, the Mono-endorsed way of specifying <b>DllImport</b> library names is to always use the Windows library name (as Microsoft .NET has no library mapping mechanism), and then provide a mapping in the per-assembly <tt>.config</tt> file. This is what the Gtk# library does. 
</p><p>This mechanism can also be used to load strongly-versioned libraries on Unix platforms. For example: 
</p>
<pre class="xml" style="font-family:monospace;"> <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;configuration<span style="color: #000000; font-weight: bold;">&gt;</span></span></span>
   <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;dllmap</span> <span style="color: #000066;">dll</span>=<span style="color: #ff0000;">&quot;gtkhtml-3.0&quot;</span> <span style="color: #000066;">target</span>=<span style="color: #ff0000;">&quot;libgtkhtml-3.0.so.4&quot;</span> <span style="color: #000000; font-weight: bold;">/&gt;</span></span>
 <span style="color: #009900;"><span style="color: #000000; font-weight: bold;">&lt;/configuration<span style="color: #000000; font-weight: bold;">&gt;</span></span></span></pre>
<h1> <span class="mw-headline" id="Invoking_Unmanaged_Code"> Invoking Unmanaged Code </span></h1>
<p>As far as managed code is concerned, unmanaged code is invoked merely by invoking a method with an associated <b>DllImport</b> attribute. The CLI runtime must do more work to actually invoke the unmanaged code. 
</p><p>In principal, this is a straightforward process. The library specified in the <b>DllImport</b> attribute is loaded, as described above. Then, the specified function is looked up (via <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/getprocaddress.asp" class="external text" rel="nofollow">GetProcAddress()</a> or <b>dlsym</b>(3)). Finally, the function is invoked. 
</p><p>But what string is used for the function lookup (in <tt>GetProcAddress()</tt> or <b>dlopen</b>(3))? By default, the name of the managed code method is used, which is why <a href="#Introduction">getpid() in the above example</a> invokes <b>getpid</b>(2) from the C library. 
</p><p>Alternatively, the <b>DllImport</b> attribute's [http:/monodoc/F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint EntryPoint] field can be set, and that string will be used instead. 
</p><p>Either way, the string used is assumed to refer to a C ABI-compatible function exported by the specified library. On some platforms, this may cause a leading underscore to be prefixed to the symbol name. Other platforms generate no mangling. 
</p><p>Note that a C ABI is assumed. This makes it nearly impossible to directly invoke functions that are not C ABI compatible, such as C++ library functions that are not <tt>extern "C"</tt>. Some variation on the C ABI is permitted, such as variation in the function's [http:/monodoc/T:System.Runtime.InteropServices.CallingConvention CallingConvention]. The default CallingConvention is platform-specific. Under Windows, [http:/monodoc/F:System.Runtime.InteropServices.CallingConvention.Winapi Winapi] is the default, as this is used for most Win32 API functions. (<b>Winapi</b> is equivalent to <b>Stdcall</b> for Windows 9x and Windows NT.)  Under Unix platforms, [http:/monodoc/F:System.Runtime.InteropServices.CallingConvention.Cdecl Cdecl] is the default. 
</p><p>Calling convention can be specified in C code by using the <tt>__stdcall</tt> and <tt>__cdecl </tt>compiler intrinsics under Microsoft Visual C++, and by using the <tt>__attribute__((stdcall)) </tt>and <tt>__attribute__((cdecl)) </tt>compiler intrinsics under GCC. 
</p><p>Does having the default CallingConvention vary between platforms cause portability problems? Yes. All the more reason to write as much code as possible as managed code, avoiding the whole P/Invoke/marshaling conundrum in the first place. 
</p><p>If you need to invoke C++ code, you have two choices: (1) make the C++ function <tt>extern "C"</tt>, treat it as a C function, and make sure that it uses a known calling convention; (2) don't make the function <tt>extern "C"</tt>, but make sure it uses a known calling convention. If you use option (2), you'll need to set the [http:/monodoc/F:System.Runtime.InteropServices.DllImportAttribute.EntryPoint DllImport.EntryPoint] field to the C++ mangled function name, such as <tt>_Z6getpidv</tt>. You can retrieve the mangled name through your compiler's binary tools, such as <tt>OBJDUMP.EXE</tt> or <b>nm</b>(1). Note that C++ mangled names are <i>highly</i> compiler specific, and will:
</p>
<ol><li> make your .NET assembly platform specific (you'll need a different assembly for each different platform); 
</li><li> require updating the .NET assembly every time you change C++ compilers (as the C++ name mangling scheme varies by compiler and can -- and frequently will -- change); and
</li><li> be really ugly to maintain because of the above. This option is not recommended. 
</li></ol>
<p>If you have lots of C++ code that needs to be wrapped, you might want to look into <a href="http://www.swig.org/" class="external text" rel="nofollow">SWIG</a>, a code generation program that easily wraps existing C and C++ code for use by a multitude of languages, including CLI languages. This makes it easier to invoke C++ code from a CLI application.  
</p><p>In case you call a function that is not present in the native library (or that is not public) you will get an EntryNotFoundException. In order to find out which symbols are available for a library, it's interesting to use the following command (the example used is a shared library from Subversion):
</p>
<pre>
objdump -T /usr/lib/libsvn_client-1.so.0
</pre>
<h2> <span class="mw-headline" id="Runtime_Exception_Propagation"> Runtime Exception Propagation </span></h2>
<p>The above section mentioned a key point: P/Invoke assumes that the unmanaged code conforms to the C ABI. C doesn't support exceptions. As such, it is assumed that runtime exceptions will not propagate through unmanaged code. 
</p><p>Furthermore, it's fairly simple for an exception to propagate through unmanaged code whenever unmanaged code invokes managed code. This typically occurs through the use of callbacks -- using a function pointer on the unmanaged side which can invoke a delegate on the managed side. It is very important that the managed code <i>not</i> propagate <i>any</i> exceptions -- it <i>must</i> catch all exceptions, or else the unmanaged code calling the delegate will break. 
</p><p>The problem is, again, C doesn't support exceptions. C++ supports exceptions, BUT, and this is crucial, the C++ exception mechanism will be different from the managed code exception mechanism (with one exception to this rule). Since managed code doesn't know about unmanaged code's exception handling support (C is assumed, and C doesn't support exceptions), unmanaged exception handling support might as well not exist, because it won't be used. 
</p>
<dl><dd> The one exception to this is when you use <i>both</i> Microsoft .NET and Microsoft Visual C++ to compile the unmanaged code. .NET uses Windows Structured Exception Handling (SEH) at the P/Invoke layer for its exception handling mechanism, and Microsoft Visual C++ uses SEH to implement C++ exception handling and supports the use of SEH in C as a language extension through the <tt>__try </tt>, <tt>__except </tt>, and <tt>__finally </tt>keywords. SEH is a Microsoft extension; it does not exist outside of Microsoft and .NET, and as such is not portable. 
</dd></dl>
<p>Given the above scenario -- unmanaged code invokes function pointer which generates a managed exception -- what would happen? The managed exception handling mechanism is executed: the stack is searched for an appropriate exception handler, then the stack is unwound, with any <tt>finally</tt> blocks executed during the stack unwind process. 
</p><p>Note two things: Managed code will be walking the stack, requiring that the CPU Stack Pointer and Instruction Pointers be set. Consequently, unmanaged code cannot participate in stack unwinding, as it will never be notified that a stack unwind is occurring. 
</p><p>Think about that for a minute. If alarms are not sounding in your head, you're in deep, deep trouble. Consider this unmanaged C code: 
</p>
<pre class="c" style="font-family:monospace;"> <span style="color: #993333;">typedef</span> <span style="color: #993333;">void</span> <span style="color: #009900;">&#40;</span><span style="color: #339933;">*</span>Handler<span style="color: #009900;">&#41;</span> <span style="color: #009900;">&#40;</span><span style="color: #993333;">const</span> <span style="color: #993333;">char</span> <span style="color: #339933;">*</span>message<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&#160;
 <span style="color: #993333;">void</span> InvokeHandler <span style="color: #009900;">&#40;</span>Handler handler<span style="color: #009900;">&#41;</span>
 <span style="color: #009900;">&#123;</span>
   <span style="color: #993333;">char</span> <span style="color: #339933;">*</span>message <span style="color: #339933;">=</span> <span style="color: #009900;">&#40;</span><span style="color: #993333;">char</span> <span style="color: #339933;">*</span><span style="color: #009900;">&#41;</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html"><span style="color: #000066;">malloc</span></a> <span style="color: #009900;">&#40;</span><span style="color: #0000dd;">10</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
   <a href="http://www.opengroup.org/onlinepubs/009695399/functions/strcpy.html"><span style="color: #000066;">strcpy</span></a> <span style="color: #009900;">&#40;</span>message<span style="color: #339933;">,</span> <span style="color: #ff0000;">&quot;A Message&quot;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
   <span style="color: #009900;">&#40;</span><span style="color: #339933;">*</span>handler<span style="color: #009900;">&#41;</span><span style="color: #009900;">&#40;</span>message<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
   <a href="http://www.opengroup.org/onlinepubs/009695399/functions/free.html"><span style="color: #000066;">free</span></a> <span style="color: #009900;">&#40;</span>message<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #009900;">&#125;</span></pre>
<p>If <i>handler</i> is a pointer to a managed delegate which may throw an exception, then <b>free</b>(3) will <i>not</i> be executed, resulting in a memory leak. C++ destructors won't help you either, as destructors still require the execution of <i>some</i> code, and that code will never be invoked, as it's not C++ which is unwinding the stack, but managed code, which doesn't know about C++ exception handling. 
</p><p>Obviously, the flip-side of this scenario -- a C++ exception being propagated into managed code -- is equally bad. As long as managed and unmanaged code use different exception handling mechanisms, exceptions <i>must not</i> be mixed between them. 
</p><p>The moral of this story: don't let exceptions propagate between managed and unmanaged code. The results won't be pretty. 
</p><p>This is particularly pertinent when wrapping C++ methods. C++ exceptions will need to be mapped into an "out" parameter or a return value, so that managed code can know what error occurred, and (optionally) throw a managed exception to "propagate" the original C++ exception. 
</p><p>See also:
</p>
<ul><li><a href="http://www.swig.org/" class="external text" rel="nofollow">SWIG</a>, a code generation program that easily wraps existing C and C++ code for use by a multitude of languages, including CLI languages. This makes it easier to invoke C++ code from a CLI application.  
</li><li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vccore98/HTML/_core_exception_handling_topics_.28.seh.29.asp" class="external text" rel="nofollow">Structured Exception Handling Topics at MSDN</a>  
</li><li><a href="http://weblogs.asp.net/cbrumme/archive/2003/10/01/51524.aspx" class="external text" rel="nofollow">The .NET Exception Model</a>: Another one of Chris Brumme's excellent blog entries. More information than you ever wanted to know about .NET exception handling.
</li></ul>
<h1> <span class="mw-headline" id="Marshaling"> Marshaling </span></h1>
<p>How does Platform Invoke work? Given a managed call site (the function call), and an unmanaged callee site (the function that's being called), each parameter in the call site is "marshaled" (converted) into an unmanaged equivalent. The marshaled data is in turn placed on the runtime stack (along with other data), and the unmanaged function is invoked. 
</p><p>The complexity is due to the marshaling. For <a href="#Blittable_Types">simple types</a>, such as integers and floating-point numbers, marshaling is a bitwise-copy ("blitting"), just as would be the case for unmanaged code. In some cases, marshaling can be avoided, such as when passing structures by reference to unmanaged code (a pointer to the structure is copied instead). It's also possible to obtain more control over marshaling, through <a href="#Custom_Marshaling">custom marshaling</a> and <a href="#Manual_Marshaling">manual marshaling</a>. 
</p><p>String types introduce additional complexity, as you need to specify the form of string conversion. The runtime stores strings as UTF-16-encoded strings, and these will likely need to be marshaled to a more appropriate form (ANSI strings, UTF-8 encoded strings, etc.). Strings get some special support. 
</p><p>Default marshaling behavior is controlled through the [http:/monodoc/T:System.Runtime.InteropServices.DllImportAttribute DllImport] and [http:/monodoc/T:System.Runtime.InteropServices.MarshalAsAttribute MarshalAs] attributes.
</p>
<h2> <span class="mw-headline" id="Memory_Boundaries"> Memory Boundaries </span></h2>
<p>Managed and unmanaged memory should be considered to be completely separate. Managed memory is typically memory allocated on a garbage-collected heap, while unmanaged memory is anything else: the ANSI C memory pool allocated through <b>malloc</b>(3), custom memory pools, and garbage-allocated heaps outside the control of the CLI implementation (such as a LISP or Scheme memory heap). 
</p><p>It is possible to lock a section of the managed heap by using the C# <tt>fixed</tt> statement. This is used so that a section of the managed heap can be passed to unmanaged code without worrying that a future GC will move the memory that the unmanaged code is operating on. However, this is completely under the control of the programmer, and is not how Platform Invoke works. 
</p><p>During a P/Invoke call the runtime doesn't mimic the C# <tt>fixed</tt> statement. Instead, classes and structures (everything of consequence) are marshaled to native code through the following pseudo-process: 
</p>
<ol><li><span id="marshal-step-1">The runtime allocates a chunk of unmanaged memory</span>.  
</li><li><span id="marshal-step-2">The managed class data is copied into the unmanaged memory</span>.  
</li><li><span id="marshal-step-3">The unmanaged function is invoked, passing it the unmanaged memory information instead of the managed memory information. This must be done so that if a GC occurs, the unmanaged function doesn't need to worry about it. (And yes, you need to worry about GCs, as the unmanaged function could call back into the runtime, ultimately leading to a GC. Multi-threaded code can also cause a GC while unmanaged code is executing.)</span>
</li><li><span id="marshal-step-4">The unmanaged memory is copied back into managed memory.</span>  
</li></ol>
<p>See <a href="#Class_and_Structure_Marshaling">Class and Structure Marshaling</a> for more detailed information about marshaling classes and structures. 
</p><p>There is one key point to keep in mind: the memory management specified in the above process is implicit, and there is no way to control how the runtime allocates the marshaled memory, or how long it lasts. This is crucial. If the runtime marshals a string (e.g. UTF-16 to Ansi conversion), the marshaled string will only last as long as the call. The unmanaged code <i>CANNOT</i> keep a reference to this memory, as it <i>WILL</i> be freed after the call ends. Failure to heed this restriction can result in "strange behavior", including memory access violations and process death. This is true for <i>any</i> marshaling process where the runtime allocates memory for the marshal process. 
</p><p>The one pseudo-exception to this point is with delegates. The unmanaged function pointer that represents the managed delegate lasts as long as the managed delegate does. When the delegate is collected by the GC, the unmanaged function pointer will also be collected. This is also important: if the delegate is collected and unmanaged memory invokes the function pointer, you're treading on thin ground. Anything could happen, including a process seg-fault. Consequently, you <i>MUST</i> ensure that the lifetime of the unmanaged function pointer is a proper subset of the lifetime of the managed delegate instance.
</p>
<h2> <span class="mw-headline" id="Blittable_Types"> Blittable Types </span></h2>
<p>Many types require minimal copying into native memory.  Blittable types are types that conceptually only require a <b>memcpy</b>(3) or can be passed on the run-time stack without translation.  These types include:
</p>
<table border="1">
<tr>
<th> C# Type </th>
<th> C Type </th>
<th> <b>&lt;stdint.h&gt;</b> Type </th>
<th> <b>&lt;glib.h&gt;</b> Type
</th></tr>
<tr>
<td> <tt>sbyte</tt> </td>
<td> <tt>char</tt> </td>
<td> <tt>int8_t</tt> </td>
<td> <tt>gint8</tt>
</td></tr>
<tr>
<td> <tt>byte</tt> </td>
<td> <tt>unsigned char</tt> </td>
<td> <tt>uint8_t</tt> </td>
<td> <tt>guint8</tt>
</td></tr>
<tr>
<td> <tt>short</tt> </td>
<td> <tt>short</tt> </td>
<td> <tt>int16_t</tt> </td>
<td> <tt>gint16</tt>
</td></tr>
<tr>
<td> <tt>ushort</tt> </td>
<td> <tt>unsigned short</tt> </td>
<td> <tt>uint16_t</tt> </td>
<td> <tt>guint16</tt>
</td></tr>
<tr>
<td> <tt>int</tt>
</td>
<td> <tt>int</tt>
<p><tt>long</tt> <i>32-bit platforms only</i> 
</p>
</td>
<td> <tt>int32_t</tt>
</td>
<td> <tt>gint32</tt>
</td></tr>
<tr>
<td> <tt>uint</tt>
</td>
<td> <tt>unsigned int</tt>
<p><tt>unsigned long</tt> <i>32-bit platforms only</i> 
</p>
</td>
<td> <tt>uint32_t</tt>
</td>
<td> <tt>guint32</tt>
</td></tr>
<tr>
<td> <tt>long</tt>
</td>
<td> <tt>long</tt> <i>64-bit platforms only</i>
<p><tt>__int64</tt> <i>MSVC</i>
</p><p><tt>long long</tt> <i>GCC</i>
</p>
</td>
<td> <tt>int64_t</tt>
</td>
<td> <tt>gint64</tt>
</td></tr>
<tr>
<td> <tt>long</tt>
</td>
<td> <tt>unsigned long</tt> <i>64-bit platforms only</i>
<p><tt>unsigned __int64</tt> <i>MSVC</i>
</p><p><tt>unsigned long long</tt> <i>GCC</i>
</p>
</td>
<td> <tt>uint64_t</tt>
</td>
<td> <tt>guint64</tt>
</td></tr>
<tr>
<td> <tt>char</tt> </td>
<td> <tt>unsigned short</tt> </td>
<td> <tt>uint16_t</tt> </td>
<td> <tt>guint16</tt>
</td></tr>
<tr>
<td> <tt>float</tt> </td>
<td> <tt>float</tt> </td>
<td> </td>
<td> <tt>gfloat</tt>
</td></tr>
<tr>
<td> <tt>double</tt> </td>
<td> <tt>double</tt> </td>
<td> </td>
<td> <tt>gdouble</tt>
</td></tr>
<tr>
<td> <tt>bool</tt> </td>
<td> <a href="#Boolean_Members">Depends on context</a> </td>
<td> </td>
<td>
</td></tr></table>
<h2> <span class="mw-headline" id="Strings"> Strings </span></h2>
<p>[http:/monodoc/T:System.String String]s are special. String marshaling behavior is also highly platform dependent. 
</p><p>String marshaling for a function call can be specified in the function declaration with the <b>DllImport</b> attribute, by setting the [http:/monodoc/F:System.Runtime.InteropServices.DllImportAttribute.CharSet CharSet] field. The default value for this field is [http:/monodoc/F:System.Runtime.InteropServices.CharSet.Auto CharSet.Ansi] . The [http:/monodoc/F:System.Runtime.InteropServices.CharSet.Auto CharSet.Auto] value implies "magic." 
</p><p>Some background. The Microsoft Win32 API supports two forms of strings: "ANSI" strings, the native character set, such as ASCII, ISO-8859-1, or a Double Byte Character Set such as Shift-JIS; and Unicode strings, originally UCS-2, and now UTF-16. Windows supports these string formats by appending an "A" for Ansi string APIs and a "W" ("wide") for Unicode string APIs. 
</p><p>Consider this Win32 API description: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;gdi32.dll&quot;</span>, CharSet<span style="color: #008000;">=</span>CharSet<span style="color: #008000;">.</span><span style="color: #0000FF;">Auto</span>, 
      CallingConvention<span style="color: #008000;">=</span>CallingConvention<span style="color: #008000;">.</span><span style="color: #0000FF;">StdCall</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
 <span style="color: #0600FF; font-weight: bold;">private</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">bool</span> TextOut <span style="color: #008000;">&#40;</span>
      <span style="color: #000000;">System</span><span style="color: #008000;">.</span><span style="color: #0000FF;">IntPtr</span> hdc,
      <span style="color: #6666cc; font-weight: bold;">int</span> nXStart,
      <span style="color: #6666cc; font-weight: bold;">int</span> nYStart,
      <span style="color: #6666cc; font-weight: bold;">string</span> lpString,
      <span style="color: #6666cc; font-weight: bold;">int</span> cbString<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<p>When TextOut is called, the "magic" properties of String marshaling become apparent. Due to string marshaling, the runtime doesn't just look for an unmanaged function with the same name as the specified method, as specified in Invoking Unmanaged Code. Other permutations of the function may be searched for, depending on the CLI runtime and the host platform. 
</p><p>There are three functions that may be searched for: 
</p>
<ul><li>TextOutW for Unicode string marshaling  
</li><li>TextOutA for Ansi string marshaling  
</li><li>TextOut with the platform-default marshaling 
</li></ul>
<p>For platforms whose default character set is UCS2 or UTF-16 Unicode (all flavors of Windows NT, and Windows XP), the default search path is TextOutW, TextOutA, and TextOut. Unicode marshaling is preferred, as (ideally) the System.String can be passed as-is to the function, as long as the function doesn't modify the string parameter. Windows CE does not look for TextOutA, as it has no Ansi APIs. 
</p><p>For platforms whose default character set is Ansi (Windows 9x, Windows ME), the default search path is TextOutA and TextOut (TextOutW is not looked for). Ansi marshaling will require translating the Unicode string into an 8-bit or DBCS string in the user's locale. Most (all?) of the time, this WILL NOT be UTF-8, so you CAN NOT assume that CharSet.Ansi will generate UTF-8-encoded strings. 
</p><p>Mono on all platforms currently uses UTF-8 encoding for all string marshaling operations.
</p><p>If you don't want the runtime to search for the alternate unmanaged functions, specify a CharSet value other than CharSet.Auto. This will cause the runtime to look only for the specified function. Note that if you pass a wrongly encoded string (e.g. calling MessageBoxW when the CharSet is CharSet.Ansi, the default), you are crossing into "undefined" territory. The unmanaged function will receive data encoded in ways it wasn't expecting, so you may get such bizarre things as Asian text when displaying "Hello, World". 
</p><p>Perhaps in the future the [http:/monodoc/T:System.Runtime.InteropServices.CharSet CharSet] enumeration will contain more choices, such as UnicodeLE (little-endian), UnicodeBE (big-endian), Utf7, Utf8, and other common choices. Additionally, making such a change would also likely require changing the UnmanagedType enumeration. However, these would need to go through ECMA, so it won't happen next week. (Unless some time has passed since this was originally written, in which case it may very well be next week. But don't count on it.)
</p>
<h3> <span class="mw-headline" id="More_Control"> More Control </span></h3>
<p>Using the <b>DllImport</b> attribute works if you want to control all the strings in a function, but what if you need more control? You would need more control if a string is a member of a structure, or if the function uses multiple different types of strings as parameters. In these circumstances, the <b>MarshalAs</b> attribute can be used, setting the [http:/monodoc/P:System.Runtime.InteropServices.MarshalAsAttribute.Value Value] property (which is set in the constructor) to a value from the [http:/monodoc/T:System.Runtime.InteropServices.UnmanagedType UnmanagedType] enumeration. For example: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;does-not-exist&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
 <span style="color: #0600FF; font-weight: bold;">private</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> Foo <span style="color: #008000;">&#40;</span>
      <span style="color: #008000;">&#91;</span>MarshalAs<span style="color: #008000;">&#40;</span>UnmanagedType<span style="color: #008000;">.</span><span style="color: #0000FF;">LPStr</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #6666cc; font-weight: bold;">string</span> ansiString,
      <span style="color: #008000;">&#91;</span>MarshalAs<span style="color: #008000;">&#40;</span>UnmanagedType<span style="color: #008000;">.</span><span style="color: #0000FF;">LPWStr</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #6666cc; font-weight: bold;">string</span> unicodeString,
      <span style="color: #008000;">&#91;</span>MarshalAs<span style="color: #008000;">&#40;</span>UnmanagedType<span style="color: #008000;">.</span><span style="color: #0000FF;">LPTStr</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #6666cc; font-weight: bold;">string</span> platformString<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<p>As you can guess by reading the example, [http:/monodoc/F:System.Runtime.InteropServices.UnmanagedType.LPStr UnmanagedType.LPStr] will marshal the input string into an Ansi string, [http:/monodoc/F:System.Runtime.InteropServices.UnmanagedType.LPWStr UnmanagedType.LPWStr] will marshal the input string into a Unicode string (effectively doing nothing), and [http:/monodoc/F:System.Runtime.InteropServices.UnmanagedType.LPTStr UnmanagedType.LPTStr] will convert the string to the platform's default string encoding.
</p><p>The default platform encoding for all flavors of Windows NT (including Windows NT 3.51 and 4.0, Windows 2000, Windows XP, Windows Server 2003) is Unicode, while for all Windows 9x flavors (Windows 95, 98, ME) the platform default encoding is Ansi.
</p><p>Mono uses UTF-8 encoding as the default encoding on all platforms.
</p><p>There are other <b>UnmangedType</b> string marshaling options, but they're primarily of interest in COM Interop ([http:/monodoc/F:System.Runtime.InteropServices.UnmanagedType.BStr BStr], [http:/monodoc/F:System.Runtime.InteropServices.UnmanagedType.AnsiBStr AnsiBStr], [http:/monodoc/F:System.Runtime.InteropServices.UnmanagedType.TBStr TBStr]). 
</p><p>If <b>UnmanagedType</b> doesn't provide enough flexibility for your string marshaling needs (for example, you're wrapping GTK+ and you need to marshal strings in UTF-8 format), look at the <a href="#Custom_Marshaling">Custom Marshaling</a> or <a href="#Manual_Marshaling">Manual Marshaling</a> sections.
</p>
<h3> <span class="mw-headline" id="Passing_Caller-Modifiable_Strings"> Passing Caller-Modifiable Strings </span></h3>
<p>A common C language idiom is for the caller to provide the callee a buffer to fill. For example, consider <b>strncpy</b>(3): 
</p>
<pre class="c" style="font-family:monospace;"> <span style="color: #993333;">char</span><span style="color: #339933;">*</span> <a href="http://www.opengroup.org/onlinepubs/009695399/functions/strncpy.html"><span style="color: #000066;">strncpy</span></a> <span style="color: #009900;">&#40;</span><span style="color: #993333;">char</span> <span style="color: #339933;">*</span>dest<span style="color: #339933;">,</span> <span style="color: #993333;">const</span> <span style="color: #993333;">char</span> <span style="color: #339933;">*</span>src<span style="color: #339933;">,</span> <span style="color: #993333;">size_t</span> n<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span></pre>
<p>We can't use <b>System.String</b> for both parameters, as strings are immutable. This is OK for <i>src</i>, but <i>dest</i> will be modified, and the caller should be able to see the modification. 
</p><p>The solution is to use a [http:/monodoc/T:System.Text.StringBuilder System.Text.StringBuilder] , which gets special marshaling support from the runtime. This would allow <b>strncpy</b>(3) to be wrapped and used as: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;libc.so&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
 <span style="color: #0600FF; font-weight: bold;">private</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> strncpy <span style="color: #008000;">&#40;</span>StringBuilder dest, 
      <span style="color: #6666cc; font-weight: bold;">string</span> src, <span style="color: #6666cc; font-weight: bold;">uint</span> n<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
 <span style="color: #0600FF; font-weight: bold;">private</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #6666cc; font-weight: bold;">void</span> UseStrncpy <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
 <span style="color: #008000;">&#123;</span>
    StringBuilder sb <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> StringBuilder <span style="color: #008000;">&#40;</span><span style="color: #FF0000;">256</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    strncpy <span style="color: #008000;">&#40;</span>sb, <span style="color: #666666;">&quot;this is the source string&quot;</span>, sb<span style="color: #008000;">.</span><span style="color: #0000FF;">Capacity</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    Console<span style="color: #008000;">.</span><span style="color: #0000FF;">WriteLine</span> <span style="color: #008000;">&#40;</span>sb<span style="color: #008000;">.</span><span style="color: #0000FF;">ToString</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>Some things to note is that the return value of <b>strncpy</b>(3) was changed to <i>void</i>, as there is no way to specify that the return value will be the same pointer address as the input <i>dest</i> string buffer, and thus it doesn't need to be marshaled. If <i>string</i> were used instead, Bad Things could happen (the returned string would be freed; see <a href="#Strings_as_Return_Values">Strings as Return Values</a> ). The <b>StringBuilder</b> is allocated with the correct amount of storage as a constructor parameter, and this amount of storage is passed to <b>strncpy</b>(3) to prevent buffer overflow.  If you use a <b>StringBuilder</b> instance multiple times, always call [http:/monodoc/M:System.Text.StringBuilder.EnsureCapacity(System.Int32) EnsureCapacity()] before passing it into the native method, as the capacity may shrink as a memory optimization over time, leading to unexpectedly truncated results.
</p><p>TODO: How does StringBuilder interact with the specified CharSet?
</p>
<h3> <span class="mw-headline" id="Strings_as_Return_Values"> Strings as Return Values </span></h3>
<p>The <b>String</b> type is a class, so <a href="#Classes_and_Structures_as_Return_Values">see the section on returning classes from functions</a>.  Summary: the runtime will attempt to free the returned pointer. The usual symptom is a runtime
crash like this:
</p>
<pre>
=================================================================
Got a SIGSEGV while executing native code. This usually indicates
a fatal error in the mono runtime or one of the native libraries
used by your application.
=================================================================

Stacktrace:

in &lt;0x4&gt; (wrapper managed-to-native) System.Object:__icall_wrapper_g_free (intptr)
in &lt;0x6b9d0c&gt; (wrapper managed-to-native) System.Object:__icall_wrapper_g_free (intptr)
</pre>
<p>If you don't want the runtime to free the returned string, either (a) don't specify the return value (<a href="#Passing_Caller-Modifiable_Strings">as was done for the <b>strncpy</b>(3) function above</a>), or (b) return an [http:/monodoc/T:System.IntPtr IntPtr] and use one of the Marshal.PtrToString* functions, depending on the type of string returned. For example, use [http:/monodoc/M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi Marshal.PtrToStringAnsi] to marshal from a Ansi string, and use [http:/monodoc/M:System.Runtime.InteropServices.Marshal.PtrToStringUni Marshal.PtrToStringUni] to marshal from a Unicode string. 
</p><p>See also:
</p>
<ul><li><a href="http://msdn.microsoft.com/en-us/library/s9ts558h(VS.80).aspx" class="external text" rel="nofollow">Default marshaling for Strings at MSDN</a>   
</li><li><a href="http://msdn.microsoft.com/netframework/default.aspx?pull=/library/en-us/dndotnet/html/manunmancode.asp" class="external text" rel="nofollow">An Overview of Managed/Unmanaged Code Interoperability</a>
</li></ul>
<h2> <span class="mw-headline" id="Class_and_Structure_Marshaling"> Class and Structure Marshaling </span></h2>
<p>The conceptual steps that occur to marshal classes and structures is detailed above, in the <a href="#Memory_Boundaries">Memory Boundaries</a> section. 
</p><p>The principal difference between class and structure marshaling is which, if any, of conceptual steps actually occurs.
</p>
<h3> <span class="mw-headline" id="Class_Marshaling"> Class Marshaling </span></h3>
<p>Remember that classes are heap-allocated and garbage-collected in the CLI. As such, you cannot pass classes by value to unmanaged functions, only by reference: 
</p>
<pre class="c" style="font-family:monospace;"> <span style="color: #808080; font-style: italic;">/* Unmanaged code declarations */</span>
 <span style="color: #993333;">struct</span> UnmanagedStruct <span style="color: #009900;">&#123;</span>
    <span style="color: #993333;">int</span> a<span style="color: #339933;">,</span> b<span style="color: #339933;">,</span> c<span style="color: #339933;">;</span>
 <span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span>
&#160;
 <span style="color: #993333;">void</span> WRONG <span style="color: #009900;">&#40;</span><span style="color: #993333;">struct</span> UnamangedStruct pass_by_value<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&#160;
 <span style="color: #993333;">void</span> RIGHT <span style="color: #009900;">&#40;</span><span style="color: #993333;">struct</span> UnmanagedStruct <span style="color: #339933;">*</span>pass_by_reference<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #993333;">void</span> RIGHT2 <span style="color: #009900;">&#40;</span><span style="color: #993333;">struct</span> UnmanagedStruct <span style="color: #339933;">**</span>pass_by_reference_out_or_ref<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span></pre>
<p>This means that you cannot use classes to invoke unmanaged functions that expect pass-by-value variables (such as the <i>WRONG</i> function, above). 
</p><p>There are two other issues with classes. First of all, classes by default use [http:/monodoc/F:System.Runtime.InteropServices.LayoutKind.Auto LayoutKind.Auto] layout. This means that the ordering of class data members is unknown, and won't be determined until runtime. The runtime can rearrange the order of members in any way it chooses, to optimize for access time or data layout space. As such, you <i>MUST</i> use the [http:/monodoc/T:System.Runtime.InteropServices.StructLayoutAttribute StructLayout] attribute and specify a [http:/monodoc/E:System.Runtime.InteropServices.LayoutKind LayoutKind] value of [http:/monodoc/F:System.Runtime.InteropServices.LayoutKind.Sequential LayoutKind.Sequential] or [http:/monodoc/F:System.Runtime.InteropServices.LayoutKind.Explicit LayoutKind.Explicit]. 
</p><p>Secondly, classes (again, by default) only have in-bound marshaling. That is, <a href="#marshal-step-4">Step 4</a> (copying the unmanaged memory representation back into managed memory) is ommitted. If you need the unmanaged memory to be copied back into managed memory, you must addorn the <b>DllImport</b> function declaration argument with an [http:/monodoc/T:System.Runtime.InteropServices.OutAttribute Out] attribute. You will also need to use the [http:/monodoc/T:System.Runtime.InteropServices.InAttribute In] attribute if you want copy-in and copy-out behavior. To summarize: 
</p>
<ul><li>Using <tt>[In]</tt> is equivalent to not specifying any parameter attributes, and will skip Step 4 (copying unmanaged memory into managed memory).  
</li><li>Using <tt>[Out]</tt> will skip Step 2 (copying managed memory into unmanaged memory).  
</li><li>Use <tt>[In, Out]</tt> to both copy managed memory to unmanaged memory before the unmanaged function call, and then copy unmanaged memory back to managed memory after the function call.  
</li></ul>
<p>In some circumstances, the marshaled copy can be omitted. The object will simply be pinned in memory and a pointer to the start of the data passed to the unmanaged function. 
</p><p>TODO: When can this actually occur? If this happened for any class with <b>Sequential</b> layout, you wouldn't need to specify the <b>Out</b> attribute, as the unmanaged code would see the actual object. Is there a specific set of circumstances for when this can occur? This appears to happen with <b>StringBuilder</b> (my tests don't require an <tt>[Out]</tt> to see changes made to the <b>StringBuilder</b> by unmanaged code), but this is the only example I can think of. 
</p><p>See Also:
</p>
<ul><li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpcondirectionalattributes.asp" class="external text" rel="nofollow">Directional Attributes (MSDN)</a>
</li></ul>
<h3> <span class="mw-headline" id="Structure_Marshaling"> Structure Marshaling </span></h3>
<p>There are two primary differences between classes and structures. First, structures do not need to be allocated on the heap; they can be allocated on the runtime stack. Secondly, they are <b>LayoutKind.Sequential</b> by default, so structure declarations do not need any additional attributes to use them with unmanaged code (assuming that the default sequential layout rules are correct for the unmanaged structure). 
</p><p>These differences permit structures to be passed by-value to unmanaged functions, unlike classes. Additionally, if (a) the structure is located on the stack, and (b) the structure contains only blittable types, then if you pass a structure to an unmanaged function by-reference, the structure will be passed directly to the unmanaged function, without an intermediate unmanaged memory copy. This means that you may not need to specify the <b>Out</b> attribute to see changes made by unmanaged code. 
</p><p>Note that as soon as the structure contains a non-blittable type (such as System.Boolean, System.String, or an array), this optimization is no longer possible and a copy of the structure must be made as part of the marshaling process. 
</p>
<h3> <span class="mw-headline" id="Classes_and_Structures_as_Return_Values"> Classes and Structures as Return Values </span></h3>
<p>The differences in allocation behavior between classes and structures also affect how they're handled as return values from functions. 
</p><p>Classes can be used as the return value of a function when the unmanaged function returns a pointer to an unmanaged structure. Classes cannot be used for by-value return types. 
</p><p>Structures can be used when the unmanaged function returns the structure by-value. It is not possible to return structures with "ref" or "out", so if an unmanaged function returns a pointer to a structure, <b>IntPtr</b> must be used for "safe" code, or a pointer to the structure can be used for "unsafe" code. If <b>IntPtr</b> is used as the return type, [http:/monodoc/M:System.Runtime.InteropServices.Marshal.PtrToStructure Marshal.PtrToStructure] can be used to convert the unmanaged pointer into a managed structure. 
</p><p>Memory management is also heavily involved. 
</p>
<h3> <span class="mw-headline" id="Memory_Management"> Memory Management </span></h3>
<p>It's easy to skim over memory management for most of Platform Invoke and marshaling, but for return values the CLI implements some default handling which must be considered. 
</p><p>The CLI runtime assumes that, under certain circumstances, the CLI runtime is responsible for freeing memory allocated by unmanaged code. Return values are one of those circumstances, causing the return value to be a memory boundary for control of memory (de)allocation. 
</p><p>The CLI assumes that all memory that is passed between the CLI/unmanaged code boundary is allocated via a common memory allocator. The developer does not get a choice in which memory allocator is used. For managed code, the [http:/monodoc/M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem Marshal.AllocCoTaskMem] method can be used to allocate memory, [http:/monodoc/M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem Marshal.FreeCoTaskMem] is used to free the memory allocated by <b>Marshal.AllocCoTaskMem</b>, and [http:/monodoc/M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem Marshal.ReAllocCoTaskMem] is used to resize a memory region originally allocated by <b>Marshal.AllocCoTaskMem</b>. 
</p><p>Since classes are passed by reference, a pointer is returned, and the runtime assumes that it must free this memory to avoid a memory leak. The chain of events is thus: 
</p>
<ol><li>Managed code invokes unmanaged function that returns a pointer to an unmanaged structure in unmanaged memory.  
</li><li>An instance of the appropriate managed class is instantiated, and the contents of the unmanaged memory is marshaled into the managed class.  
</li><li>The unmanaged memory is freed by the runtime "as if" by invoking <b>Marshal.FreeCoTaskMem()</b>.  
</li></ol>
<p>How is <b>Marshal.AllocCoTaskMem</b>, <b>Marshal.ReAllocCoTaskMem</b>, and <b>Marshal.FreeCoTaskMem</b> implemented? That's platform-dependent. (So much for portable platform-dependent code.) Under Windows, the COM Task Memory allocator is used (via <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/com/html/c4cb588d-9482-4f90-a92e-75b604540d5c.asp" class="external text" rel="nofollow">CoTaskMemAlloc()</a>, <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/com/html/c4cb588d-9482-4f90-a92e-75b604540d5c.asp" class="external text" rel="nofollow">CoTaskMemReAlloc()</a>, and <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/com/html/c4cb588d-9482-4f90-a92e-75b604540d5c.asp" class="external text" rel="nofollow">CoTaskMemFree()</a>). Under Unix, the GLib memory functions <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Memory-Allocation.html#g-malloc" class="external text" rel="nofollow">g_malloc()</a> , <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Memory-Allocation.html#g-realloc" class="external text" rel="nofollow">g_realloc()</a> , and <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Memory-Allocation.html#g-free" class="external text" rel="nofollow">g_free()</a> functions are used. Typically, these correspond to the ANSI C functions <b>malloc</b>(3), <b>realloc</b>(3), and <b>free</b>(3), but this is not necessarily the case as GLib can use different memory allocators; see <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Memory-Allocation.html#g-mem-set-vtable" class="external text" rel="nofollow">g_mem_set_vtable()</a> and <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Memory-Allocation.html#g-mem-is-system-malloc" class="external text" rel="nofollow">g_mem_is_system_malloc()</a> . 
</p><p>What do you do if you don't want the runtime to free the memory? Don't return a class. Instead, return an IntPtr (the moral equivalent of a C <tt>void*</tt> pointer), and then use the <b>Marshal</b> class methods to manipulate that pointer, such as [http:/monodoc/M:System.Runtime.InteropServices.Marshal.PtrToStructure Marshal.PtrToStructure], which works for both C# <b>struct</b> types and <b>class</b> types marked <tt>[StructLayout(LayoutKind.Sequential)]</tt>.
</p>
<h3> <span class="mw-headline" id="Choosing_between_Classes_and_Structures"> Choosing between Classes and Structures </span></h3>
<p>So which should be used when wrapping unmanaged code, classes or structures? 
</p><p>Generally, the answer to this question depends upon what the unmanaged code requires. If you require pass-by-value semantics, you must use structures. If you want to return a pointer to an unmanaged type without resorting to "unsafe" or manual code, you must use classes (assuming that the default <a href="#Memory_Management">memory allocation rules</a> are appropriate). 
</p><p>For the large intersection of unmanaged code that doesn't have pass-by-value structures or return pointers to structures from functions? Use whichever is more convenient for the end user. Not all languages support passing types by reference (Java, for example), so using classes will permit a larger body of languages to use the wrapper library.  Furthermore, Microsoft suggests that structure sizes not exceed 16 bytes.
</p>
<h2> <span class="mw-headline" id="Summary"> Summary </span></h2>
<p>It's always easier to show the code, so... Given the following unmanaged code declarations: 
</p>
<pre class="c" style="font-family:monospace;"> <span style="color: #808080; font-style: italic;">/* unmanaged code declarations */</span>
&#160;
 <span style="color: #993333;">struct</span> UnmanagedStruct <span style="color: #009900;">&#123;</span>
    <span style="color: #993333;">int</span> n<span style="color: #339933;">;</span>
 <span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span>
&#160;
 <span style="color: #993333;">void</span> PassByValue <span style="color: #009900;">&#40;</span><span style="color: #993333;">struct</span> UnmanagedStruct s<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&#160;
 <span style="color: #993333;">void</span> PassByReferenceIn <span style="color: #009900;">&#40;</span><span style="color: #993333;">struct</span> UnmanagedStruct <span style="color: #339933;">*</span>s<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #993333;">void</span> PassByReferenceOut <span style="color: #009900;">&#40;</span><span style="color: #993333;">struct</span> UnmanagedStruct <span style="color: #339933;">*</span>s<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #993333;">void</span> PassByReferenceInOut <span style="color: #009900;">&#40;</span><span style="color: #993333;">struct</span> UnmanagedStruct <span style="color: #339933;">*</span>s<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&#160;
 <span style="color: #993333;">struct</span> UnmanagedStruct ReturnByValue <span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #993333;">struct</span> UnmanagedStruct<span style="color: #339933;">*</span> ReturnByReference <span style="color: #009900;">&#40;</span><span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
&#160;
 <span style="color: #993333;">void</span> DoubleIndirection <span style="color: #009900;">&#40;</span><span style="color: #993333;">struct</span> UnmanagedStruct <span style="color: #339933;">**</span>s<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span></pre>
<p>The class wrapper could be: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008080; font-style: italic;">/* note: sequential layout */</span>
 <span style="color: #008000;">&#91;</span>StructLayout <span style="color: #008000;">&#40;</span>LayoutKind<span style="color: #008000;">.</span><span style="color: #0000FF;">Sequential</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
 <span style="color: #6666cc; font-weight: bold;">class</span> ClassWrapper <span style="color: #008000;">&#123;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> n<span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* cannot wrap function PassByValue */</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* PassByReferenceIn */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> 
       <span style="color: #6666cc; font-weight: bold;">void</span> PassByReferenceIn <span style="color: #008000;">&#40;</span>ClassWrapper s<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* PassByReferenceOut */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> 
       <span style="color: #6666cc; font-weight: bold;">void</span> PassByReferenceOut <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#91;</span><span style="color: #0600FF; font-weight: bold;">Out</span><span style="color: #008000;">&#93;</span> ClassWrapper s<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* PassByReferenceInOut */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> 
       <span style="color: #6666cc; font-weight: bold;">void</span> PassByReferenceInOut <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#91;</span><span style="color: #0600FF; font-weight: bold;">In</span>, <span style="color: #0600FF; font-weight: bold;">Out</span><span style="color: #008000;">&#93;</span> ClassWrapper s<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* cannot wrap function ReturnByValue */</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* ReturnByReference */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> ClassWrapper ReturnByReference <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       <span style="color: #008080; font-style: italic;">/* note: this causes returned pointer to be freed 
          by runtime */</span>
     <span style="color: #008080; font-style: italic;">/* DoubleIndirection */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> 
       <span style="color: #6666cc; font-weight: bold;">void</span> DoubeIndirection <span style="color: #008000;">&#40;</span><span style="color: #0600FF; font-weight: bold;">ref</span> ClassWrapper s<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>While the structure wrapper could be: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #6666cc; font-weight: bold;">struct</span> StructWrapper <span style="color: #008000;">&#123;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> n<span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* PassByValue */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> PassByValue <span style="color: #008000;">&#40;</span>StructWrapper s<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* PassByReferenceIn */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> PassByReferenceIn <span style="color: #008000;">&#40;</span>
       <span style="color: #0600FF; font-weight: bold;">ref</span> StructWrapper s<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* PassByReferenceOut */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> PassByReferenceOut <span style="color: #008000;">&#40;</span>
       <span style="color: #0600FF; font-weight: bold;">out</span> StructWrapper s<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* PassByReferenceInOut */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> PassByReferenceInOut <span style="color: #008000;">&#40;</span>
       <span style="color: #0600FF; font-weight: bold;">ref</span> StructWrapper s<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* ReturnByValue */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> StructWrapper ReturnByValue <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* ReturnByReference: CLS-compliant way */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span>, EntryPoint<span style="color: #008000;">=</span><span style="color: #666666;">&quot;ReturnByReference&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> IntPtr ReturnByReferenceCLS <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       <span style="color: #008080; font-style: italic;">/* note: this DOES NOT cause returned pointer to be 
          freed by the runtime, so it's not identical to
          ClassWrapper.ReturnByReference.
          Use Marshal.PtrToStructure() to access the 
          underlying structure. */</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* ReturnByReference: &quot;unsafe&quot; way */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span>, EntryPoint<span style="color: #008000;">=</span><span style="color: #666666;">&quot;ReturnByReference&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">unsafe</span> <span style="color: #0600FF; font-weight: bold;">extern</span> StructWrapper<span style="color: #008000;">*</span> 
       ReturnByReferenceUnsafe <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       <span style="color: #008080; font-style: italic;">/* note: this DOES NOT cause returned pointer to be 
          freed by the runtime, so it's not identical to
          ClassWrapper.ReturnByReference */</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* DoubleIndirection: CLS-compliant way */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span>, EntryPoint<span style="color: #008000;">=</span><span style="color: #666666;">&quot;DoubleIndirection&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> 
       <span style="color: #6666cc; font-weight: bold;">void</span> DoubeIndirectionCLS <span style="color: #008000;">&#40;</span><span style="color: #0600FF; font-weight: bold;">ref</span> IntPtr s<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       <span style="color: #008080; font-style: italic;">/* note: this is similar to ReturnByReferenceCLS().
          Pass a `ref IntPtr' to the function, then use
          Marshal.PtrToStructure() to access the 
          underlying structure. */</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* DoubleIndirection: &quot;unsafe&quot; way */</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;mylib&quot;</span>, EntryPoint<span style="color: #008000;">=</span><span style="color: #666666;">&quot;DoubleIndirection&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">unsafe</span> <span style="color: #0600FF; font-weight: bold;">extern</span> 
       <span style="color: #6666cc; font-weight: bold;">void</span> DoubeIndirectionUnsafe <span style="color: #008000;">&#40;</span>StructWrapper <span style="color: #008000;">**</span>s<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
 <span style="color: #008000;">&#125;</span></pre>
<h2> <span class="mw-headline" id="Marshaling_Class_and_Structure_Members"> Marshaling Class and Structure Members </span></h2>
<p>Aside from the major differences between classes and structures outlined above, the members of classes and structures are marshaled identically. 
</p><p>The general rule of advice is this: never pass classes or structures containing members of reference type (classes) to unmanaged code. This is because unmanaged code can't do anything safely with the unmanaged reference (pointer), and the CLI runtime doesn't do a "deep marshal" (marshal members of marshaled classes, and their members, ad infinitum). 
</p><p>The immediate net effect of this is that you can't have array members in marshaled classes, and (as we've seen before) handling strings can be "wonky" (as strings are also a reference type). 
</p><p>Furthermore, the default string marshaling is the <a href="#More_Control">platform default</a> , though this can be changed by setting the [http:/monodoc/F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet StructLayoutAttribute.CharSet] field, which defaults to <b>CharSet.Auto</b>. Alternatively, you can adorn string members with the <b>MarshalAs</b> attribute to specify what kind of string they are. 
</p>
<h3> <span class="mw-headline" id="Boolean_Members"> Boolean Members </span></h3>
<p>The [http:/monodoc/T:System.Boolean System.Boolean] (<b>bool</b> in C#) type is special. (FUBAR might be more appropriate.) A <tt>bool</tt> within a structure is marshaled as an <tt>int</tt> (a 4-byte integer), with 0 being <tt>false </tt>and non-zero being <tt>true</tt>; see [http:/monodoc/F:System.Runtime.InteropServices.UnmanagedType.Bool UnmanagedType.Bool] . A <tt>bool</tt> passed as an argument to a function is marshaled as a <tt>short</tt> (a 2-byte integer), with 0 being <tt>false</tt> and -1 being <tt>true</tt> (as all bits are set); see [http:/monodoc/F:System.Runtime.InteropServices.UnmanagedType.VariantBool UnmanagedType.VariantBool] . 
</p><p>You can always explicitly specify the marshaling to use by using the <b>MarshalAsAttribute</b> on the boolean member, but there are only three legal UnmanagedType values: <b>UnmanagedType.Bool</b>, <b>UnmanagedType.VariantBool</b>, and [http:/monodoc/F:System.Runtime.InteropServices.UnmanagedType.U1 UnmanagedType.U1]. <b>UnmanagedType.U1</b> , the only un-discussed type, is a 1-byte integer where 1 represents <tt>true</tt> and 0 represents <tt>false</tt>. 
</p><p>If you need to marshal as another data type, you should overload the method accepting the boolean parameter, and manually convert the boolean to your desired type: 
</p>
<pre class="c" style="font-family:monospace;"> <span style="color: #666666; font-style: italic;">// Unmanaged C declaration:</span>
 <span style="color: #993333;">void</span> DoSomething <span style="color: #009900;">&#40;</span><span style="color: #993333;">int</span> boolean<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span></pre>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008080; font-style: italic;">// Managed declaration:</span>
 <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;SomeLibrary&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
 <span style="color: #0600FF; font-weight: bold;">private</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> DoSomething <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">int</span> boolean<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
 <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #6666cc; font-weight: bold;">void</span> DoSomething <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">bool</span> boolean<span style="color: #008000;">&#41;</span>
 <span style="color: #008000;">&#123;</span>
    DoSomething <span style="color: #008000;">&#40;</span>boolean <span style="color: #008000;">?</span> <span style="color: #FF0000;">1</span> <span style="color: #008000;">:</span> <span style="color: #FF0000;">0</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>See also: <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpcondefaultmarshalingforbooleans.asp" class="external text" rel="nofollow">Default Marshaling for Boolean Types</a>
</p>
<h3> <span class="mw-headline" id="Unions"> Unions </span></h3>
<p>A C union (in which multiple members share the same offset into a structure) can be simulated by using the [http:/monodoc/T:System.Runtime.InteropServices.FieldOffsetAttribute FieldOffset] attribute and specifying the same offset for the union members.
</p>
<h3> <span class="mw-headline" id="Longs"> Longs </span></h3>
<p>The C 'long' type is difficult to marshal as a struct member, since there is no CLR type which matches it, i.e. 'int' is 32 bit, 'long' is 64 bit, while C's 'long' can be 32 bit or 64 bit, dependending on the platform.
There are two possible solutions:
</p>
<ul><li> Using two sets of structures, one for 32 bit and one for 64 bit platforms.
</li><li> Mapping C 'long' to 'IntPtr'. This will work on all 32 bit and 64 bit platforms, _except_ 64 bit windows, where sizeof(long)==4 and sizeof(void*)==8. See <a href="http://stackoverflow.com/questions/384502/what-is-the-bit-size-of-long-on-64-bit-windows" class="external text" rel="nofollow">This</a>.
</li></ul>
<h3> <span class="mw-headline" id="Arrays_Embedded_Within_Structures"> Arrays Embedded Within Structures </span></h3>
<p>Inline arrays can be marshaled by using a <b>MarshalAs</b> attribute with <b>UnmanagedType.ByValArray</b> and specifying the [http:/monodoc/F:System.Runtime.InteropServices.MarshalAsAttribute.SizeConst MarshalAsAttribute.SizeConst] field to the size of the array to marshal. Inline arrays which contain strings can use <b>UnmanagedType.ByValTStr</b> for a string. 
</p><p>However, the runtime doesn't automatically allocate arrays specified as <b>UnmanagedType.ByValArray</b>. The programmer is still responsible for allocating the managed array. See the <a href="#marshaling-members-summary">summary</a> for more information. 
</p><p>TODO: Bernie Solomon says that for <tt>out</tt> parameters, the runtime will allocate the inline array memory. Check this out. 
</p><p>For example, the unmanaged structure: 
</p>
<pre class="c" style="font-family:monospace;"> <span style="color: #993333;">struct</span> UnmanagedStruct <span style="color: #009900;">&#123;</span>
    <span style="color: #993333;">int</span> data<span style="color: #009900;">&#91;</span><span style="color: #0000dd;">10</span><span style="color: #009900;">&#93;</span><span style="color: #339933;">;</span>
    <span style="color: #993333;">char</span> name<span style="color: #009900;">&#91;</span><span style="color: #0000dd;">32</span><span style="color: #009900;">&#93;</span><span style="color: #339933;">;</span>
 <span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span></pre>
<p><i>Can</i> be represented in C# as: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #6666cc; font-weight: bold;">struct</span> ManagedStruct_Slow <span style="color: #008000;">&#123;</span>
    <span style="color: #008000;">&#91;</span>MarshalAs <span style="color: #008000;">&#40;</span>UnmanagedType<span style="color: #008000;">.</span><span style="color: #0000FF;">ByValArray</span>, SizeConst<span style="color: #008000;">=</span><span style="color: #FF0000;">10</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span><span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span>  data<span style="color: #008000;">;</span>
    <span style="color: #008000;">&#91;</span>MarshalAs <span style="color: #008000;">&#40;</span>UnmanagedType<span style="color: #008000;">.</span><span style="color: #0000FF;">ByValTStr</span>, SizeConst<span style="color: #008000;">=</span><span style="color: #FF0000;">32</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">string</span> name<span style="color: #008000;">;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>Of course, the managed structure can be declared in other ways, with varying performance and usage tradeoffs. The previous declaration is the most straightforward to use, but has the worst performance characteristics. The following structure will marshal faster, but will be more difficult to work with: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #6666cc; font-weight: bold;">struct</span> ManagedStruct_Fast_1 <span style="color: #008000;">&#123;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span>  data_0, data_1, data_2, data_3, data_4,
                data_5, data_6, data_7, data_8, data_9<span style="color: #008000;">;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">byte</span> name_00, name_01, name_02, name_03, name_04, 
                name_05, name_06, name_07, name_08, name_09,
                name_10, name_11, name_12, name_13, name_14,
                name_15, name_16, name_17, name_18, name_19,
                name_20, name_21, name_22, name_23, name_24,
                name_25, name_26, name_27, name_28, name_29,
                name_30, name_31,
 <span style="color: #008000;">&#125;</span></pre>
<p>Yet another alternative is to directly specify the size of the structure, instead of letting the structure contents dictate the structure size. This is done via the [http:/monodoc/F:System.Runtime.InteropServices.StructLayout.Size StructLayout.Size] field. This makes the structure terribly annoying to deal with, as pointer arithmetic must be used to deal with the <tt>name</tt> member: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008000;">&#91;</span>StructLayout<span style="color: #008000;">&#40;</span>LayoutKind<span style="color: #008000;">.</span><span style="color: #0000FF;">Sequential</span>, Size<span style="color: #008000;">=</span><span style="color: #FF0000;">72</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
 <span style="color: #6666cc; font-weight: bold;">struct</span> ManagedStruct_Fast_2 <span style="color: #008000;">&#123;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span>  data_0, data_1, data_2, data_3, data_4,
                data_5, data_6, data_7, data_8, data_9<span style="color: #008000;">;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">byte</span> name<span style="color: #008000;">;</span> <span style="color: #008080; font-style: italic;">/* first byte of name */</span>
    <span style="color: #008080; font-style: italic;">/* Size property specifies that 31 bytes of nameless
       &quot;space&quot; is placed here. */</span>
 <span style="color: #008000;">&#125;</span></pre>
<h4> <span class="mw-headline" id="C.23_2.0_Functionality"> C# 2.0 Functionality </span></h4>
<p>C# 2.0 adds language features to deal with inline arrays, using a <b>fixed</b> array syntax. This allows the previous structure to be declard as: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #6666cc; font-weight: bold;">struct</span> ManagedStruct_v2 <span style="color: #008000;">&#123;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">fixed</span> <span style="color: #6666cc; font-weight: bold;">int</span>  data<span style="color: #008000;">&#91;</span><span style="color: #FF0000;">10</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">fixed</span> <span style="color: #6666cc; font-weight: bold;">byte</span> name<span style="color: #008000;">&#91;</span><span style="color: #FF0000;">32</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>Fixed array syntax is still "unsafe", and requires elevated privilege to execute. 
</p>
<h4> <span class="mw-headline" id="Real_World_Experience"> Real World Experience </span></h4>
<p>This might be of use. From David Jesk ( <a href="http://www.chat.net/~jeske/" class="external free" rel="nofollow">http://www.chat.net/~jeske/</a> ): 
</p>
<blockquote>
This time I have some PInvoke information to share, so that when someone else runs into this issue they can see what I've done. 
 
In my ClearSilver (www.clearsilver.net, an HTML template system) C# wrapper, I wanted to access this C-struct: 
 
<pre class="c" style="font-family:monospace;"> <span style="color: #993333;">typedef</span> <span style="color: #993333;">struct</span> _neo_err
 <span style="color: #009900;">&#123;</span>
   <span style="color: #993333;">int</span> error<span style="color: #339933;">;</span>
   <span style="color: #993333;">int</span> err_stack<span style="color: #339933;">;</span>
   <span style="color: #993333;">int</span> flags<span style="color: #339933;">;</span>
   <span style="color: #993333;">char</span> desc<span style="color: #009900;">&#91;</span><span style="color: #0000dd;">256</span><span style="color: #009900;">&#93;</span><span style="color: #339933;">;</span>
   <span style="color: #993333;">const</span> <span style="color: #993333;">char</span> <span style="color: #339933;">*</span>file<span style="color: #339933;">;</span>
   <span style="color: #993333;">const</span> <span style="color: #993333;">char</span> <span style="color: #339933;">*</span>func<span style="color: #339933;">;</span>
   <span style="color: #993333;">int</span> lineno<span style="color: #339933;">;</span>
   <span style="color: #808080; font-style: italic;">/* internal use only */</span>
   <span style="color: #993333;">struct</span> _neo_err <span style="color: #339933;">*</span>next<span style="color: #339933;">;</span>
 <span style="color: #009900;">&#125;</span> NEOERR<span style="color: #339933;">;</span></pre>
<p>My philosophy of using unsafe struct pointers, and just accessing the struct out in unmanaged memory is great, and it's exactly what I want to do. However, handling "char dest[256]" is not straightforward. 
</p><p>In C# arrays are reference types. Using one makes the struct a managed type, and I can't put the array size in. The following is conceptually what I want to do, however, it's obviously invalid: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008000;">&#91;</span>StructLayout<span style="color: #008000;">&#40;</span>LayoutKind<span style="color: #008000;">.</span><span style="color: #0000FF;">Sequential</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
 <span style="color: #0600FF; font-weight: bold;">unsafe</span> <span style="color: #6666cc; font-weight: bold;">struct</span> NEOERR <span style="color: #008000;">&#123;</span>
   <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> error<span style="color: #008000;">;</span>
   <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> err_stack<span style="color: #008000;">;</span>
   <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> flags<span style="color: #008000;">;</span>
   <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">byte</span><span style="color: #008000;">&#91;</span><span style="color: #FF0000;">256</span><span style="color: #008000;">&#93;</span> desc<span style="color: #008000;">;</span>  <span style="color: #008080; font-style: italic;">// this is invalid, </span>
                           <span style="color: #008080; font-style: italic;">// can't contain size</span>
   <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">const</span> <span style="color: #6666cc; font-weight: bold;">byte</span> <span style="color: #008000;">*</span>file<span style="color: #008000;">;</span> 
   <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">const</span> <span style="color: #6666cc; font-weight: bold;">byte</span> <span style="color: #008000;">*</span>func<span style="color: #008000;">;</span> 
   <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> lineno<span style="color: #008000;">;</span>
&#160;
   <span style="color: #008080; font-style: italic;">/* internal use only */</span>
   <span style="color: #0600FF; font-weight: bold;">private</span> NEOERR <span style="color: #008000;">*</span>next<span style="color: #008000;">;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>This dosn't work either: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008000;">&#91;</span>MarshalAs <span style="color: #008000;">&#40;</span>UnmanagedType<span style="color: #008000;">.</span><span style="color: #0000FF;">LPStr</span>, SizeConst<span style="color: #008000;">=</span><span style="color: #FF0000;">256</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> 
 <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">string</span> desc<span style="color: #008000;">;</span></pre>
<p>Because in this case, I don't want to marshal the data. I just want to talk to it in place. The solution I could come up with is this: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008000;">&#91;</span>StructLayout<span style="color: #008000;">&#40;</span>LayoutKind<span style="color: #008000;">.</span><span style="color: #0600FF; font-weight: bold;">Explicit</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
 <span style="color: #0600FF; font-weight: bold;">unsafe</span> <span style="color: #6666cc; font-weight: bold;">struct</span> NEOERR <span style="color: #008000;">&#123;</span>
   <span style="color: #008000;">&#91;</span>FieldOffset<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">0</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> error<span style="color: #008000;">;</span>
   <span style="color: #008000;">&#91;</span>FieldOffset<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">4</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> err_stack<span style="color: #008000;">;</span>
   <span style="color: #008000;">&#91;</span>FieldOffset<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">8</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> flags<span style="color: #008000;">;</span>
   <span style="color: #008080; font-style: italic;">// public byte[256] dest;  // not representable</span>
&#160;
   <span style="color: #008080; font-style: italic;">// use this as an address??</span>
   <span style="color: #008000;">&#91;</span>FieldOffset<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">12</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">byte</span> dest_first_char<span style="color: #008000;">;</span>
   <span style="color: #008000;">&#91;</span>FieldOffset<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">268</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">byte</span> <span style="color: #008000;">*</span>file<span style="color: #008000;">;</span> <span style="color: #008080; font-style: italic;">// const</span>
   <span style="color: #008000;">&#91;</span>FieldOffset<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">272</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">byte</span> <span style="color: #008000;">*</span>func<span style="color: #008000;">;</span> <span style="color: #008080; font-style: italic;">// const</span>
   <span style="color: #008000;">&#91;</span>FieldOffset<span style="color: #008000;">&#40;</span><span style="color: #FF0000;">276</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> lineno<span style="color: #008000;">;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>UGH! First, this is obviously annoying. Second, the only way I can figure to get access to "char dest[256]" is to use "char* dest = &amp;nerr-&gt;dest_first_char;" and then just use dest as a pointer to the string. I've dug through the documentation, and I can't find any better solution. 
</p><p>Obviously it would be ideal if there were a way to represent a value-type array. I wonder how Managed C++ handles "char foo[256];" in a struct. 
</p>
</blockquote>
<p>See also: 
</p>
<ul><li><a href="http://weblogs.asp.net/ericgu/archive/2004/08/12/213676.aspx" class="external text" rel="nofollow">Eric Gunnerson's C# Blog: Arrays inside of structures</a>
</li></ul>
<h3> <span class="mw-headline" id="Summary_2"> <span id="marshaling-members-summary">Summary</span> </span></h3>
<p>Again, example native code... 
</p>
<pre class="c" style="font-family:monospace;"> <span style="color: #808080; font-style: italic;">/* original code */</span>
 <span style="color: #993333;">struct</span> UnmanagedInformation <span style="color: #009900;">&#123;</span>
    <span style="color: #993333;">int</span> num<span style="color: #339933;">;</span>
    <span style="color: #993333;">char</span><span style="color: #339933;">*</span> string<span style="color: #339933;">;</span>
    <span style="color: #993333;">int</span> array<span style="color: #009900;">&#91;</span><span style="color: #0000dd;">32</span><span style="color: #009900;">&#93;</span><span style="color: #339933;">;</span>
&#160;
    <span style="color: #993333;">union</span> <span style="color: #009900;">&#123;</span>
       <span style="color: #993333;">int64_t</span> addr<span style="color: #339933;">;</span>  <span style="color: #808080; font-style: italic;">/* from &lt;stdint.h&gt;, C99 */</span>
       <span style="color: #993333;">double</span> other<span style="color: #339933;">;</span>
    <span style="color: #009900;">&#125;</span> stuff<span style="color: #339933;">;</span>
 <span style="color: #009900;">&#125;</span><span style="color: #339933;">;</span></pre>
<p>And the possible corresponding managed code: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008080; font-style: italic;">/* managed representation */</span>
 <span style="color: #008000;">&#91;</span>StructLayout <span style="color: #008000;">&#40;</span>LayoutKind<span style="color: #008000;">.</span><span style="color: #0600FF; font-weight: bold;">Explicit</span>, CharSet<span style="color: #008000;">=</span>CharSet<span style="color: #008000;">.</span><span style="color: #0000FF;">Ansi</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
 <span style="color: #6666cc; font-weight: bold;">struct</span> ManagedInformation <span style="color: #008000;">&#123;</span>
    <span style="color: #008000;">&#91;</span>FieldOffset <span style="color: #008000;">&#40;</span><span style="color: #FF0000;">0</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #6666cc; font-weight: bold;">int</span> num<span style="color: #008000;">;</span>
    <span style="color: #008000;">&#91;</span>FieldOffset <span style="color: #008000;">&#40;</span><span style="color: #FF0000;">4</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #6666cc; font-weight: bold;">string</span> str<span style="color: #008000;">;</span>
    <span style="color: #008000;">&#91;</span>FieldOffset <span style="color: #008000;">&#40;</span><span style="color: #FF0000;">8</span><span style="color: #008000;">&#41;</span>, 
       MarshalAs <span style="color: #008000;">&#40;</span>UnmanagedType<span style="color: #008000;">.</span><span style="color: #0000FF;">ByValArray</span>, SizeConst<span style="color: #008000;">=</span><span style="color: #FF0000;">32</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #6666cc; font-weight: bold;">int</span><span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span> array<span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">/* union members */</span>
    <span style="color: #008000;">&#91;</span>FieldOffset <span style="color: #008000;">&#40;</span><span style="color: #FF0000;">136</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #6666cc; font-weight: bold;">long</span> stuff_addr<span style="color: #008000;">;</span>
    <span style="color: #008000;">&#91;</span>FieldOffset <span style="color: #008000;">&#40;</span><span style="color: #FF0000;">136</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #6666cc; font-weight: bold;">double</span> stuff_other<span style="color: #008000;">;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>Note that this isn't an exact match to the unmanaged code. This structure must be built in two phases to match the unmanaged representation: (1) create the structure, and (2) allocate memory for ManagedInformation.array. For example: 
</p>
<pre class="csharp" style="font-family:monospace;"> ManagedInformation info <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> ManagedInformation <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
 info<span style="color: #008000;">.</span><span style="color: #0000FF;">array</span> <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> <span style="color: #6666cc; font-weight: bold;">int</span><span style="color: #008000;">&#91;</span><span style="color: #FF0000;">32</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">;</span></pre>
<h3> <span class="mw-headline" id="A_Warning_about_FieldOffset"> A Warning about FieldOffset </span></h3>
<p>The <b>FieldOffset</b> attribute has one major pitfall: it makes offsets of types explicit. This is liable to break if (when) (1) the class/structure contains a pointer, reference, or array, and (2) you change the bitsize of your processor (move from a 32-bit processor to a 64-bit processor). It is preferable to use <b>LayoutKind.Sequential</b> if at all possible, as the runtime will take care of updating the structural offsets when the size of pointers changes. 
</p><p>TODO: include MSDN examples using the more esotoric <b>MarshalAs</b> fields, such as <b>SizeParamIndex</b>, <b>ArraySubType</b>, etc. 
</p><p>See also: *<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconmarshalingdatawithplatforminvoke.asp" class="external text" rel="nofollow">Marshaling Data with Platform Invoke at MSDN</a>, *<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconarrayssample.asp" class="external text" rel="nofollow">Arrays Sample at MSDN</a>   
</p>
<h3> <span class="mw-headline" id="Marshaling_Pointers"> Marshaling Pointers </span></h3>
<p>Didn't we start using a managed execution environment to <i>avoid </i>pointers? But I digress... 
</p><p>Alas, pointers are a fact of life in unmanaged code. As the <a href="#Avoiding_Marshaling">Avoiding Marshaling</a> section points out, there are two ways to represent pointers: the "safe" way, using [http:/monodoc/T:System.IntPtr System.IntPtr] or [http:/monodoc/T:System.UIntPtr System.UIntPtr] , and the "unsafe" way, by using <tt>unsafe</tt> code and pointers. 
</p>
<h4> <span class="mw-headline" id="Marshaling_Embedded_Strings"> Marshaling Embedded Strings </span></h4>
<p><i>Behold the topic that just won't die!</i> "Inline" strings -- in which the storage for the string is part of the structure itself -- were covered <a href="#Arrays_Embedded_Within_Structures">previously</a>. Obviously, and likely more commonly, strings are not always allocated within the structure; typically a pointer to a null-terminated string is stored. 
</p><p>The typical approach is to map the string as an IntPtr, and use [http:/monodoc/M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi Marshal.PtrToStringAnsi] and similar functions to manually marshal the string. 
</p><p>Why manually marshal? Because you typically use a custom memory allocator (such as <b>malloc</b>(3)), and don't want the runtime incorrectly freeing the memory that the string references. In this case, it's <i>essential</i> that you manually marshal the string to avoid memory corruption.
</p>
<h2> <span class="mw-headline" id="Custom_Marshaling"> Custom Marshaling </span></h2>
<p>The [http:/monodoc/T:System.Runtime.InteropServices.ICustomMarshaler ICustomMarshaler] interface allows the CLI
to invoke custom code as part of the P/Invoke call.  Normal P/Invoke calls
follow the structure:
</p>
<blockquote><p>
Method invocation &#8594; CLI P/Invoke Default Marshaler &#8594; Unmanaged
method call
</p></blockquote>
<p>Custom marshaling allows this to become
</p>
<blockquote><p>
Method invocation &#8594; CLI P/Invoke Default Marshaler &#8594; custom marshaler
&#8594; CLI P/Invoke marshaler &#8594; Unmanaged method call
</p></blockquote>
<p>In order for the custom marshaler to be invoked, 
</p>
<ol><li> the custom marshaler must implement the <b>ICustomMarshaler</b> interface, and
</li><li> the custom marshaler must provide a static <b>GetInstance</b> method which takes a string and returns a <b>ICustomMarshaler</b> instance:
</li></ol>
<dl><dd><pre class="csharp" style="font-family:monospace;"><span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> ICustomMarshaler GetInstance <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">string</span> s<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
</dd></dl>
<ol><li> The <b>DllImport</b> declaration must have a parameter with a <b>MarshalAs</b> attribute specifying [http:/monodoc/F:System.Runtime.InteropServices.UnmanagedType.CustomMarshaler UnmanagedType.CustomMarshaler] and:
<ul><li> The [http:/monodoc/F:System.Runtime.InteropServices.MarshalAsAttribute.MarshalTypeRef MarshalTypeRef] or [http:/monodoc/F:System.Runtime.InteropServices.MarshalAsAttribute.MarshalType MarshalType] fields.
</li><li> (Optionally) The [http:/monodoc/F:System.Runtime.InteropServices.MarshalAsAttribute.MarshalCookie MarshalCookie] field.  This string is passed to <b>GetInstance</b>.
</li></ul>
</li></ol>
<p>An example custom marshaler can be found in the
<b>Mono.Unix.Native.FileNameMarshaler</b> (<a href="http://anonsvn.mono-project.com/viewvc/trunk/mcs/class/Mono.Posix/Mono.Unix.Native/FileNameMarshaler.cs" class="external text" rel="nofollow">FileNameMarshaler.cs</a>) and in the Mono unit tests (<a href="http://anonsvn.mono-project.com/viewvc/trunk/mono/mono/tests/marshal9.cs" class="external text" rel="nofollow">marshal9.cs</a>).
</p><p>Given all the work involved with custom marshaling, such as the required
<b>ICustomMarshaler</b> class implementation and <b>MarshalAs</b> attributes,
what is the advantage of custom marshaling over <a href="#Manual_Marshaling">manual marshaling</a>?  Maintenance.  For only one method, manual marshaling is simpler:
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008080; font-style: italic;">// Custom Marshaling with Mono.Unix.Native.FileNameMarshaler.cs</span>
 <span style="color: #008000;">&#91;</span>DllImport<span style="color: #008000;">&#40;</span>LIB<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
 <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">int</span> open <span style="color: #008000;">&#40;</span>
    <span style="color: #008000;">&#91;</span>MarshalAs <span style="color: #008000;">&#40;</span>UnmanagedType<span style="color: #008000;">.</span><span style="color: #0000FF;">CustomMarshaler</span>, 
       MarshalTypeRef<span style="color: #008000;">=</span><a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a><span style="color: #008000;">&#40;</span>Mono<span style="color: #008000;">.</span><span style="color: #0000FF;">Unix</span><span style="color: #008000;">.</span><span style="color: #0000FF;">Native</span><span style="color: #008000;">.</span><span style="color: #0000FF;">FileNameMarshaler</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #6666cc; font-weight: bold;">string</span> pathname, 
    <span style="color: #6666cc; font-weight: bold;">int</span> flags
 <span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<p>And the manual marshaler implementation:
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008080; font-style: italic;">// Use Manual Marshaling</span>
 <span style="color: #008000;">&#91;</span>DllImport<span style="color: #008000;">&#40;</span>LIB<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
 <span style="color: #0600FF; font-weight: bold;">private</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">int</span> open <span style="color: #008000;">&#40;</span>IntPtr pathname, <span style="color: #6666cc; font-weight: bold;">int</span> flags<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
 <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">int</span> open <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">string</span> pathname, <span style="color: #6666cc; font-weight: bold;">int</span> flags<span style="color: #008000;">&#41;</span>
 <span style="color: #008000;">&#123;</span>
    IntPtr _pathname <span style="color: #008000;">=</span> UnixMarshal<span style="color: #008000;">.</span><span style="color: #0000FF;">StringToHeap</span> <span style="color: #008000;">&#40;</span>pathname, 
          UnixEncoding<span style="color: #008000;">.</span><span style="color: #0000FF;">Instance</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #0600FF; font-weight: bold;">try</span> <span style="color: #008000;">&#123;</span>
       <span style="color: #0600FF; font-weight: bold;">return</span> open <span style="color: #008000;">&#40;</span>_pathname, flags<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
    <span style="color: #0600FF; font-weight: bold;">finally</span> <span style="color: #008000;">&#123;</span>
       UnixMarshal<span style="color: #008000;">.</span><span style="color: #0000FF;">FreeHeap</span> <span style="color: #008000;">&#40;</span>_pathname<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>However, as the number of methods that require essentially identical
marshaling increases, it becomes easier to maintain the custom marshaler than
to maintain the <i>N</i> separate manual marshal copies that would otherwise be
necessary.
</p><p><br /> 
See also: *<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpref/html/frlrfsystemruntimeinteropservicesicustommarshalerclasstopic.asp" class="external text" rel="nofollow">ICustomMarshal Interface at MSDN</a>
</p>
<h2> <span class="mw-headline" id="Manual_Marshaling"> Manual Marshaling </span></h2>
<p>What do you do when the default marshaling rules (amid all the variations that the <b>DllImport</b> and <b>MarshalAs</b> attributes permit) don't allow you to invoke a given function?  You do it manually by making extensive use of the [http:/monodoc/T:System.Runtime.InteropServices.Marshal Marshal] class methods.
</p><p>TODO: finish.
</p>
<h3> <span class="mw-headline" id="Marshaling_char.2A.2A"> Marshaling char** </span></h3>
<p>Note: The original howto can be found here: <a href="http://hisham.cc/files/howto/marshalling_strings/" class="external free" rel="nofollow">http://hisham.cc/files/howto/marshalling_strings/</a>
</p><p>The key in the following tutorial is System.Runtime.InteropServices, where we can find the Marshal class. That class is very useful because it bridges created managed objects and unmanaged ones. Its functionalities are very similar to blocks, unsafe, and more. For example, let's say that all pointer types in .NET are saved in an instance of the type IntPtr. With the Marshal class, we can perform any operation like adding a determined number of bytes in order to point to other objects, and converting things that are there in a structure or a chain (other thing is if in that memory direction is something with sense or not).
</p><p>Using this piece of code, we can see how to put data into an unmanaged structure through a pointer obtained from a function or an external public structure of a native library.
</p><p>By default C#, establishes the order that is most optimized for the structure fields in memory. Nevertheless, if we want to dump the contents of the unmanaged pointer in our structure correctly, all the fields must maintain their order and size (in bytes). To solve this problem, we apply the attribute StructLayout(LayoutKind.Sequential) on the structure.
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008000;">&#91;</span>StructLayout<span style="color: #008000;">&#40;</span>LayoutKind<span style="color: #008000;">.</span><span style="color: #0000FF;">Sequential</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
   <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">class</span> _EcoreEventDndEnter
     <span style="color: #008000;">&#123;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> IntPtr win<span style="color: #008000;">;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> IntPtr src<span style="color: #008000;">;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> IntPtr types<span style="color: #008000;">;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> num_types<span style="color: #008000;">;</span> 
        <span style="color: #0600FF; font-weight: bold;">public</span> _EcoreEventDndEnter<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> 
          <span style="color: #008000;">&#123;</span><span style="color: #008000;">&#125;</span>
     <span style="color: #008000;">&#125;</span></pre>
<p>The structure has two pointers to X windows, a pointer to a character matrix (a string table), and an integer that defines the number of present chains. It seems to be a complex structure, but it isn't.
</p><p>We want to create a class from that structure. So, we have a constructor with a parameter that points to the unmarshalled structure. Afterwards, we use the Marshal class in order to utilize its basic types. Everything is straight forward except for the matrix that couldn't be converted without producing an error. The Mono.UnixMarshal class solves that problem, which was basically a portability issue: 
</p>
<pre class="csharp" style="font-family:monospace;">   <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">class</span> EcoreEventDndEnter
     <span style="color: #008000;">&#123;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> Window win<span style="color: #008000;">;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> Window src<span style="color: #008000;">;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">string</span><span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span> types<span style="color: #008000;">;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> num_types<span style="color: #008000;">;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> EcoreEventDndEnter<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
          <span style="color: #008000;">&#123;</span><span style="color: #008000;">&#125;</span>
&#160;
        <span style="color: #0600FF; font-weight: bold;">public</span> EcoreEventDndEnter<span style="color: #008000;">&#40;</span>IntPtr EventInfo<span style="color: #008000;">&#41;</span>
          <span style="color: #008000;">&#123;</span>
             _EcoreEventDndEnter e <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> _EcoreEventDndEnter<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
             e <span style="color: #008000;">=</span> <span style="color: #008000;">&#40;</span>_EcoreEventDndEnter<span style="color: #008000;">&#41;</span>Marshal<span style="color: #008000;">.</span><span style="color: #0000FF;">PtrToStructure</span><span style="color: #008000;">&#40;</span>EventInfo, <a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a><span style="color: #008000;">&#40;</span>_EcoreEventDndEnter<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
             win <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> Window<span style="color: #008000;">&#40;</span>e<span style="color: #008000;">.</span><span style="color: #0000FF;">win</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
             src <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> Window<span style="color: #008000;">&#40;</span>e<span style="color: #008000;">.</span><span style="color: #0000FF;">src</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
             types <span style="color: #008000;">=</span> Mono<span style="color: #008000;">.</span><span style="color: #0000FF;">Unix</span><span style="color: #008000;">.</span><span style="color: #0000FF;">UnixMarshal</span><span style="color: #008000;">.</span><span style="color: #0000FF;">PtrToStringArray</span><span style="color: #008000;">&#40;</span>e<span style="color: #008000;">.</span><span style="color: #0000FF;">types</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
             num_types <span style="color: #008000;">=</span> e<span style="color: #008000;">.</span><span style="color: #0000FF;">num_types</span><span style="color: #008000;">;</span>
          <span style="color: #008000;">&#125;</span>
     <span style="color: #008000;">&#125;</span></pre>
<p>The fact that Mono is open-source helped understand that MonoUnix is merely an extension of System.Runtime.InteropServices.Marshal, using the same methods of the Marshal class. This means that we can put the necessary code of UnixMarshal in the project in order to guarantee its portability from Windows Mono or even .NET. Here's the piece of code:
</p>
<pre class="csharp" style="font-family:monospace;">&#160;
   <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">class</span> Common
     <span style="color: #008000;">&#123;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #6666cc; font-weight: bold;">string</span> PtrToString <span style="color: #008000;">&#40;</span>IntPtr p<span style="color: #008000;">&#41;</span>
          <span style="color: #008000;">&#123;</span>
             <span style="color: #008080; font-style: italic;">// TODO: deal with character set issues.  Will PtrToStringAnsi always</span>
             <span style="color: #008080; font-style: italic;">// &quot;Do The Right Thing&quot;?</span>
             <span style="color: #0600FF; font-weight: bold;">if</span> <span style="color: #008000;">&#40;</span>p <span style="color: #008000;">==</span> IntPtr<span style="color: #008000;">.</span><span style="color: #0000FF;">Zero</span><span style="color: #008000;">&#41;</span>
               <span style="color: #0600FF; font-weight: bold;">return</span> <span style="color: #0600FF; font-weight: bold;">null</span><span style="color: #008000;">;</span>
             <span style="color: #0600FF; font-weight: bold;">return</span> Marshal<span style="color: #008000;">.</span><span style="color: #0000FF;">PtrToStringAnsi</span> <span style="color: #008000;">&#40;</span>p<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
          <span style="color: #008000;">&#125;</span>
&#160;
&#160;
        <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #6666cc; font-weight: bold;">string</span><span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span> PtrToStringArray <span style="color: #008000;">&#40;</span>IntPtr stringArray<span style="color: #008000;">&#41;</span>
          <span style="color: #008000;">&#123;</span>
             <span style="color: #0600FF; font-weight: bold;">if</span> <span style="color: #008000;">&#40;</span>stringArray <span style="color: #008000;">==</span> IntPtr<span style="color: #008000;">.</span><span style="color: #0000FF;">Zero</span><span style="color: #008000;">&#41;</span>
               <span style="color: #0600FF; font-weight: bold;">return</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> <span style="color: #6666cc; font-weight: bold;">string</span><span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">&#123;</span><span style="color: #008000;">&#125;</span><span style="color: #008000;">;</span>
&#160;
&#160;
             <span style="color: #6666cc; font-weight: bold;">int</span> argc <span style="color: #008000;">=</span> CountStrings <span style="color: #008000;">&#40;</span>stringArray<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
             <span style="color: #0600FF; font-weight: bold;">return</span> PtrToStringArray <span style="color: #008000;">&#40;</span>argc, stringArray<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
          <span style="color: #008000;">&#125;</span>
&#160;
        <span style="color: #0600FF; font-weight: bold;">private</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #6666cc; font-weight: bold;">int</span> CountStrings <span style="color: #008000;">&#40;</span>IntPtr stringArray<span style="color: #008000;">&#41;</span>
          <span style="color: #008000;">&#123;</span>
             <span style="color: #6666cc; font-weight: bold;">int</span> count <span style="color: #008000;">=</span> <span style="color: #FF0000;">0</span><span style="color: #008000;">;</span>
             <span style="color: #0600FF; font-weight: bold;">while</span> <span style="color: #008000;">&#40;</span>Marshal<span style="color: #008000;">.</span><span style="color: #0000FF;">ReadIntPtr</span> <span style="color: #008000;">&#40;</span>stringArray, count<span style="color: #008000;">*</span>IntPtr<span style="color: #008000;">.</span><span style="color: #0000FF;">Size</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">!=</span> IntPtr<span style="color: #008000;">.</span><span style="color: #0000FF;">Zero</span><span style="color: #008000;">&#41;</span>
               <span style="color: #008000;">++</span>count<span style="color: #008000;">;</span>
             <span style="color: #0600FF; font-weight: bold;">return</span> count<span style="color: #008000;">;</span>
          <span style="color: #008000;">&#125;</span>
&#160;
&#160;
        <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #6666cc; font-weight: bold;">string</span><span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span> PtrToStringArray <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">int</span> count, IntPtr stringArray<span style="color: #008000;">&#41;</span>
          <span style="color: #008000;">&#123;</span>
             <span style="color: #0600FF; font-weight: bold;">if</span> <span style="color: #008000;">&#40;</span>count <span style="color: #008000;">&lt;</span> <span style="color: #FF0000;">0</span><span style="color: #008000;">&#41;</span>
               <span style="color: #0600FF; font-weight: bold;">throw</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> ArgumentOutOfRangeException <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;count&quot;</span>, <span style="color: #666666;">&quot;&lt; 0&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
             <span style="color: #0600FF; font-weight: bold;">if</span> <span style="color: #008000;">&#40;</span>stringArray <span style="color: #008000;">==</span> IntPtr<span style="color: #008000;">.</span><span style="color: #0000FF;">Zero</span><span style="color: #008000;">&#41;</span>
               <span style="color: #0600FF; font-weight: bold;">return</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> <span style="color: #6666cc; font-weight: bold;">string</span><span style="color: #008000;">&#91;</span>count<span style="color: #008000;">&#93;</span><span style="color: #008000;">;</span>
&#160;
&#160;
             <span style="color: #6666cc; font-weight: bold;">string</span><span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span> members <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> <span style="color: #6666cc; font-weight: bold;">string</span><span style="color: #008000;">&#91;</span>count<span style="color: #008000;">&#93;</span><span style="color: #008000;">;</span>
             <span style="color: #0600FF; font-weight: bold;">for</span> <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">int</span> i <span style="color: #008000;">=</span> <span style="color: #FF0000;">0</span><span style="color: #008000;">;</span> i <span style="color: #008000;">&lt;</span> count<span style="color: #008000;">;</span> <span style="color: #008000;">++</span>i<span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#123;</span>
                IntPtr s <span style="color: #008000;">=</span> Marshal<span style="color: #008000;">.</span><span style="color: #0000FF;">ReadIntPtr</span> <span style="color: #008000;">&#40;</span>stringArray, i <span style="color: #008000;">*</span> IntPtr<span style="color: #008000;">.</span><span style="color: #0000FF;">Size</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
                members<span style="color: #008000;">&#91;</span>i<span style="color: #008000;">&#93;</span> <span style="color: #008000;">=</span> PtrToString <span style="color: #008000;">&#40;</span>s<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
             <span style="color: #008000;">&#125;</span>
&#160;
&#160;
             <span style="color: #0600FF; font-weight: bold;">return</span> members<span style="color: #008000;">;</span>
          <span style="color: #008000;">&#125;</span>
     <span style="color: #008000;">&#125;</span></pre>
<pre>After the following step, the final class is completely portable:
</pre>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">class</span> EcoreEventDndEnter
     <span style="color: #008000;">&#123;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> Window win<span style="color: #008000;">;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> Window src<span style="color: #008000;">;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">string</span><span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span> types<span style="color: #008000;">;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> num_types<span style="color: #008000;">;</span>
        <span style="color: #0600FF; font-weight: bold;">public</span> EcoreEventDndEnter<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
          <span style="color: #008000;">&#123;</span><span style="color: #008000;">&#125;</span>
&#160;
        <span style="color: #0600FF; font-weight: bold;">public</span> EcoreEventDndEnter<span style="color: #008000;">&#40;</span>IntPtr EventInfo<span style="color: #008000;">&#41;</span>
          <span style="color: #008000;">&#123;</span>
             _EcoreEventDndEnter e <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> _EcoreEventDndEnter<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
             e <span style="color: #008000;">=</span> <span style="color: #008000;">&#40;</span>_EcoreEventDndEnter<span style="color: #008000;">&#41;</span>Marshal<span style="color: #008000;">.</span><span style="color: #0000FF;">PtrToStructure</span><span style="color: #008000;">&#40;</span>EventInfo, <a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a><span style="color: #008000;">&#40;</span>_EcoreEventDndEnter<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
             win <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> Window<span style="color: #008000;">&#40;</span>e<span style="color: #008000;">.</span><span style="color: #0000FF;">win</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
             src <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> Window<span style="color: #008000;">&#40;</span>e<span style="color: #008000;">.</span><span style="color: #0000FF;">src</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
             types <span style="color: #008000;">=</span> Common<span style="color: #008000;">.</span><span style="color: #0000FF;">PtrToStringArray</span><span style="color: #008000;">&#40;</span>e<span style="color: #008000;">.</span><span style="color: #0000FF;">types</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
             num_types <span style="color: #008000;">=</span> e<span style="color: #008000;">.</span><span style="color: #0000FF;">num_types</span><span style="color: #008000;">;</span>
          <span style="color: #008000;">&#125;</span>
     <span style="color: #008000;">&#125;</span></pre>
<h1> <span class="mw-headline" id="Avoiding_Marshaling"> Avoiding Marshaling </span></h1>
<p>Marshaling is no panacea, as marshaling implies copying data. Marshaling may be problematic because the data translation is a complex, time-consuming process. Alternatively, it may be problematic because it isn't possible to copy the data, as the data isn't known or is likely to change. 
</p><p>An example of the latter would be the GTK+ libraries. GTK+ is an object-oriented toolkit written in C. As with all object-oriented libraries, there can be an unknown number of derived classes, each of which having a different class size. Furthermore, class instances are typically accessed through pointers. As such, marshaling the entire class between managed and unmanaged memory is not an option, as a copy isn't desired, access to the same instance is. 
</p><p>Another example is when using "opaque" data types; that is, types through which interaction is solely through pointers, and nothing about the internals of the type is public. This describes a large portion of the Win32 API, where HANDLE is used to represent most objects. 
</p><p>There are two ways to handle this in C#: the "type-safe" way, which involves using pointers and the "unsafe" C# language features, and the CLS-compliant way, which uses System.IntPtr to stand in for a void pointer. 
</p><p>In both cases, the separation between managed and unmanaged memory is made explicit. Managed memory remains type-safe, while unmanaged memory is not (since [http:/monodoc/T:System.IntPtr System.IntPtr] is used to point into unmanaged memory, and there is no way to ensure the actual type of what the System.IntPtr refers to). 
</p><p>Be warned that this may not be safe, if the "unmanaged" memory is itself garbage collected. This may be the case if the unmanaged memory is handled by a different runtime system (Python, Ruby, Lisp, etc.) or a garbage collector is being used (Boehm). If the unmanaged memory is garbage collected, then the System.IntPtr won't be updated when unmanaged memory undergoes a garbage collection, resulting in memory corruption. 
</p><p>For example, given the unmanaged API: 
</p>
<pre class="c" style="font-family:monospace;"> <span style="color: #993333;">typedef</span> <span style="color: #993333;">void</span><span style="color: #339933;">*</span> HANDLE<span style="color: #339933;">;</span>
&#160;
 bool CreateItem <span style="color: #009900;">&#40;</span>HANDLE <span style="color: #339933;">*</span>item<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #993333;">void</span> DestroyItem <span style="color: #009900;">&#40;</span>HANDLE item<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span>
 <span style="color: #993333;">int</span> GetInfo <span style="color: #009900;">&#40;</span>HANDLE item<span style="color: #009900;">&#41;</span><span style="color: #339933;">;</span></pre>
<p>The "type-safe" C# wrapper (using "unsafe" code) is: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #6666cc; font-weight: bold;">struct</span> Item <span style="color: #008000;">&#123;</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;library&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">unsafe</span> <span style="color: #0600FF; font-weight: bold;">extern</span> 
       <span style="color: #6666cc; font-weight: bold;">bool</span> CreateItem <span style="color: #008000;">&#40;</span><span style="color: #0600FF; font-weight: bold;">out</span> Item<span style="color: #008000;">*</span> item<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;library&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">unsafe</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> DestroyItem <span style="color: #008000;">&#40;</span>Item<span style="color: #008000;">*</span> item<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;library&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">unsafe</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">int</span> GetInfo <span style="color: #008000;">&#40;</span>Item<span style="color: #008000;">*</span> item<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
 <span style="color: #008000;">&#125;</span>
&#160;
 <span style="color: #6666cc; font-weight: bold;">class</span> ExampleUsage <span style="color: #008000;">&#123;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">unsafe</span> <span style="color: #6666cc; font-weight: bold;">void</span> Main <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
       Item<span style="color: #008000;">*</span> item<span style="color: #008000;">;</span>
       Item<span style="color: #008000;">.</span><span style="color: #0000FF;">CreateItem</span> <span style="color: #008000;">&#40;</span><span style="color: #0600FF; font-weight: bold;">out</span> item<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       <span style="color: #6666cc; font-weight: bold;">int</span> n <span style="color: #008000;">=</span> Item<span style="color: #008000;">.</span><span style="color: #0000FF;">GetInfo</span> <span style="color: #008000;">&#40;</span>item<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       <span style="color: #000000;">System</span><span style="color: #008000;">.</span><span style="color: #0000FF;">Console</span><span style="color: #008000;">.</span><span style="color: #0000FF;">WriteLine</span> <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;item count: {0}&quot;</span>, 
          n<span style="color: #008000;">.</span><span style="color: #0000FF;">ToString</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       Item<span style="color: #008000;">.</span><span style="color: #0000FF;">DestroyItem</span> <span style="color: #008000;">&#40;</span>item<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>This is "type-safe" in that you can't pass arbitrary memory locations to the static Item functions, you must pass a pointer to an Item structure. This isn't a strict amount of type safety, but it is likely to minimize accidental memory corruption. It's biggest problem is that it uses "unsafe" code, and thus may not be usable from other .NET languages, such as Visual Basic .NET and JavaScript. 
</p><p>The CLS compliant version uses System.IntPtr to refer to unmanaged memory. This is similar to what the [http:/monodoc/T:System.Runtime.InteropServices.Marshal Marshal] class does to interoperate with unmanaged memory. 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #6666cc; font-weight: bold;">class</span> Item <span style="color: #008000;">&#123;</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;library&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">bool</span> 
       CreateItem <span style="color: #008000;">&#40;</span><span style="color: #0600FF; font-weight: bold;">out</span> <span style="color: #000000;">System</span><span style="color: #008000;">.</span><span style="color: #0000FF;">IntPtr</span> item<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;library&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> DestroyItem <span style="color: #008000;">&#40;</span><span style="color: #000000;">System</span><span style="color: #008000;">.</span><span style="color: #0000FF;">IntPtr</span> item<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;library&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">int</span> GetInfo <span style="color: #008000;">&#40;</span><span style="color: #000000;">System</span><span style="color: #008000;">.</span><span style="color: #0000FF;">IntPtr</span> item<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
 <span style="color: #008000;">&#125;</span>
&#160;
 <span style="color: #6666cc; font-weight: bold;">class</span> ExampleUsage <span style="color: #008000;">&#123;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">unsafe</span> <span style="color: #6666cc; font-weight: bold;">void</span> Main <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
       <span style="color: #000000;">System</span><span style="color: #008000;">.</span><span style="color: #0000FF;">IntPtr</span> item <span style="color: #008000;">=</span> <span style="color: #0600FF; font-weight: bold;">null</span><span style="color: #008000;">;</span>
       Item<span style="color: #008000;">.</span><span style="color: #0000FF;">CreateItem</span> <span style="color: #008000;">&#40;</span><span style="color: #0600FF; font-weight: bold;">out</span> item<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       <span style="color: #6666cc; font-weight: bold;">int</span> n <span style="color: #008000;">=</span> Item<span style="color: #008000;">.</span><span style="color: #0000FF;">GetInfo</span> <span style="color: #008000;">&#40;</span>item<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       <span style="color: #000000;">System</span><span style="color: #008000;">.</span><span style="color: #0000FF;">Console</span><span style="color: #008000;">.</span><span style="color: #0000FF;">WriteLine</span> <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;item count: {0}&quot;</span>, 
          n<span style="color: #008000;">.</span><span style="color: #0000FF;">ToString</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       Item<span style="color: #008000;">.</span><span style="color: #0000FF;">DestroyItem</span> <span style="color: #008000;">&#40;</span>item<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>This is "unsafe" in that it is easier to accidentally mis-use pointers. For example, if you're using two different libraries and wrapping them using System.IntPtr, it is possible to pass an object allocated from one library to a function exported by the other library, and the CLI Runtime will not catch this error, while the "unsafe" C# code would catch this error. 
</p><p>However, this isn't normally considered a problem, as most managed code shouldn't interact with P/Invoke code, but should instead interact with managed wrappers for the unmanaged code, which can provide a more natural interface to managed clients. 
</p>
<h2> <span class="mw-headline" id="GC-Safe_P.2FInvoke_code"> GC-Safe P/Invoke code </span></h2>
<p>There's one problem with the wrapper code described above: a race-condition between user code and the runtime Garbage Collector (GC). 
</p><p>The GC that .NET uses is not conservative. It knows all types involved, and can distinguish between an integer that looks like a pointer and an actual pointer value. It knows all stack-allocated variables, and what the scope of those variables is. Finally, the GC does not see into unmanaged code. 
</p><p>The result of this is that it's possible the the GC to collect a class instance <i>while a method of the instance is still executing </i>. 
</p><p>How is this possible? If the method no longer references class data (instance members), and no other code refers to it, the GC may collect the class. After all, if no instance members are used and no one is using the instance, what's it matter if the instance is collected? 
</p><p>It matters a lot if unmanaged code thinks that the instance is still alive. Or, if the class has a finalizer, which could be executed while native code is executing from within the native method. 
</p><p>Here is an example adapted from Chris Brumme's blog: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #6666cc; font-weight: bold;">class</span> C <span style="color: #008000;">&#123;</span>
    <span style="color: #008080; font-style: italic;">// handle into unmanaged memory, for an unmanaged object</span>
    IntPtr _handle<span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// performs some operation on h</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;...&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> OperateOnHandle <span style="color: #008000;">&#40;</span>IntPtr h<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// frees resources of h</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;...&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> DeleteHandle <span style="color: #008000;">&#40;</span>IntPtr h<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    ~C<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
       DeleteHandle<span style="color: #008000;">&#40;</span>h<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
&#160;
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">void</span> m<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
       OperateOnHandle<span style="color: #008000;">&#40;</span>_handle<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       <span style="color: #008080; font-style: italic;">// no further references to _handle</span>
    <span style="color: #008000;">&#125;</span>
 <span style="color: #008000;">&#125;</span>
&#160;
 <span style="color: #6666cc; font-weight: bold;">class</span> Other
 <span style="color: #008000;">&#123;</span>
    <span style="color: #6666cc; font-weight: bold;">void</span> work<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
       C c <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> C<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       c<span style="color: #008000;">.</span><span style="color: #0000FF;">m</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       <span style="color: #008080; font-style: italic;">// no further references to c.  </span>
       <span style="color: #008080; font-style: italic;">// c is now eligable for collection.</span>
    <span style="color: #008000;">&#125;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>Consider this: <tt>Other.work </tt>invokes <tt>C.m </tt>, which invokes the unmanaged code <tt>C.OperateOnHandle </tt>. Note that <tt>Other.work </tt>doesn't use <tt>c </tt>anymore, so <tt>c </tt>is eligible to be collected, and is placed on the GC finalization queue. 
</p><p>This would normally be reasonable, except for the interplay with unmanaged code. The unmanaged code <tt>C.OperateOnHandle </tt>is still using a member held by the instance <tt>c </tt>, but the GC doesn't -- and <i>can't </i>-- know this. 
</p><p>This introduces the possibility that, although unlikely, <tt>C.DeleteHandle </tt>will be invoked (from the GC finalization thread) <i>while </i> <tt>C.OperateOnHandle </tt>is still operating. 
</p><p>It's fair to assume that the unmanaged code won't appreciate this. It's fair to assume that this could cause major problems for the process, including a segmentation fault. 
</p><p>In fact, a bug very similar to this exists in .NET v1.0, in one of the Registry wrapper classes. 
</p><p>How do you avoid this problem? Don't use raw IntPtrs. With the IntPtr being used, the GC has no way of knowing that the class still needs to hang around. To avoid the bug, we avoid IntPtrs. 
</p><p>Instead of using IntPtr, we use [http:/monodoc/T:System.Runtime.InteropServices.HandleRef HandleRef] . This is a structure which holds both a reference to the containing class, as well as the pointer value. 
</p><p>Next, instead of having the P/Invoke code accept IntPtr parameters, the P/Invoke code accepts HandleRefs. HandleRefs are special to the runtime and GC system, and during a marshal operation they "collapse" into an IntPtr. 
</p><p>This allows us to write the safe code: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #6666cc; font-weight: bold;">class</span> C <span style="color: #008000;">&#123;</span>
    <span style="color: #008080; font-style: italic;">// handle into unmanaged memory, for an unmanaged object</span>
    HandleRef _handle<span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// performs some operation on h</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;...&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> OperateOnHandle <span style="color: #008000;">&#40;</span>HandleRef h<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// frees resources of h</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;...&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> <span style="color: #6666cc; font-weight: bold;">void</span> DeleteHandle <span style="color: #008000;">&#40;</span>HandleRef h<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// Creates Resource</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;...&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> IntPtr CreateHandle <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #0600FF; font-weight: bold;">public</span> C<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
       IntPtr h <span style="color: #008000;">=</span> CreateHandle<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       _handle <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> HandleRef<span style="color: #008000;">&#40;</span><span style="color: #0600FF; font-weight: bold;">this</span>, h<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
&#160;
    ~C<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
       DeleteHandle<span style="color: #008000;">&#40;</span>h<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
&#160;
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">void</span> m <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
       OperateOnHandle<span style="color: #008000;">&#40;</span>_handle<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       <span style="color: #008080; font-style: italic;">// no further references to _handle</span>
    <span style="color: #008000;">&#125;</span>
 <span style="color: #008000;">&#125;</span>
&#160;
 <span style="color: #6666cc; font-weight: bold;">class</span> Other
 <span style="color: #008000;">&#123;</span>
    <span style="color: #6666cc; font-weight: bold;">void</span> work <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
       <span style="color: #008080; font-style: italic;">// Note: no change to client</span>
       C c <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> C<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       c<span style="color: #008000;">.</span><span style="color: #0000FF;">m</span><span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>See also: <a href="http://blogs.msdn.com/cbrumme/archive/2003/04/19/51365.aspx" class="external text" rel="nofollow">Chris Brumme's Blog: Lifetime, GC.KeepAlive, handle recycling</a>
</p>
<h3> <span class="mw-headline" id=".NET_2.0_and_SafeHandles"> .NET 2.0 and SafeHandles </span></h3>
<p>In .NET 2.0, a new mechanism for wrapping unmanaged handles was introduced.  This new mechanism is exposed by the [http:/monodoc/T:System.Runtime.InteropServices.SafeHandle SafeHandle] class.  SafeHandles encapsulate a handle in the form of an IntPtr, but by exposing it as a subclass of the SafeHandle class (for example [http:/monodoc/T:Microsoft.Win32.SafeFileHandle SafeFileHandle] or [http:/monodoc/T:Microsoft.Win32.SafeWaitHandle SafeWaitHandle]) developers gain type safety.
</p><p>SafeHandles in addition provide a mechanism to avoid inadvertent handle recycling (for references <a href="http://blogs.msdn.com/cbrumme/archive/2004/02/20/77460.aspx" class="external autonumber" rel="nofollow">[1]</a> <a href="http://blogs.msdn.com/bclteam/archive/2005/03/15/396335.aspx" class="external autonumber" rel="nofollow">[2]</a>).
</p><p>The runtime treats SafeHandles specially and will automatically provide marshalling of these when used in P/Invoke calls.   The behavior depends on its use:
</p>
<ul><li> On outgoing parameters, the SafeHandle's handle is passed.
</li><li> On return values, a new instance of the concrete SafeHandle class is created, and the handle value is set to the returned IntPtr value.
</li><li> On ref SafeHandles, the outgoing value is ignored (must be zero) and the returned value is turned into a proper SafeHandle.
</li><li> On structure fields, the SafeHandle's handle is passed.
</li></ul>
<p>For the actual implementation details in Mono, see the <a href="{{site.baseurl}}/SafeHandles" title="SafeHandles">SafeHandles</a> document.
</p>
<h2> <span class="mw-headline" id="Properly_Disposing_of_Resources"> Properly Disposing of Resources </span></h2>
<p>When avoiding marshaling, you're referencing unmanaged memory and other resources from managed code. This confers a great deal of responsibility. It also creates a great deal of concern, as more things can "go wrong" in managed code, particularly because of exceptions and related complexity. When any function can throw an exception, ensuring that resources are properly disposed of can be a tricky matter. 
</p><p>As suggested in the <a href="#GC-Safe_P.2FInvoke_code">previous section</a>, a simple way to ensure that resources are eventually disposed is to wrap the resource within a class containing a finalizer. The finalizer can then free the resource. 
</p><p>There are two problems with that approach, both of which have to do with the garbage collector: 
</p>
<ol><li>The garbage collector cannot see into unmanaged memory, it only deals with managed memory. Thus, if you have a large amount of memory in unmanaged memory (such as images or video data), all the GC will see is the <b>IntPtr</b>(s) that refer to this data, and not the size of the unmanaged memory "held" by the managed code. Consequently, the GC won't know that a collection should be executed (there won't be any "memory pressure" to cause a collection). <p>This is partially fixed in .NET 2.0 by using the <a href="http://msdn2.microsoft.com/en-us/library/system.gc.addmemorypressure.aspx" class="external text" rel="nofollow">System.GC.AddMemoryPressure(long)</a> method, which can be used to tell the GC how much unmanaged memory a managed object is referencing, which can improve the GC heuristics. However, code needs to be modified to support this approach and does not work with .NET 1.1 code.</p>   
</li><li>The .NET garbage collector does not execute an object's finalizer when the object is collected. Instead, the object is promoted a generation, and the object's finalizer is executed the next time that generation is collected. <p>For example, if a Generation 0 object with a finalizer is eligible for collection (i.e. no objects reference it), the object is promoted a generation, and placed on the Generation 1 finalization queue. The next time Generation 1 is collected, the object's finalizer will be executed.</p> 
</li></ol>
<p>Problem 2 is a real killer, as collection frequency is inversely proportional to the generation number. Generation 0 is (typically) collected 10 times as frequently as Generation 1, which in turn is collected 10 times as frequently as Generation 2. Generation 2 is intended to be <i>rarely </i>collected, as these should be long-term objects that persist through the life of the application. 
</p><p>Given that the soonest a finalizer is collected is after two collections, one for Generation 0 and one for Generation 1 (which occurs after ~10 Generation 0 collections), it can be a <i>long time</i> before a finalizer is executed. Relying on finalizers for resource disposal and collection is a <i>BAD IDEA</i>, even before considering that finalizers are not guaranteed to be executed, especially at program shutdown. 
</p><p>Fortunately, there is a simple pattern used throughout the .NET Class Libraries to help ensure that resources are disposed of quickly: 
</p>
<ul><li>Implement the [http:/monodoc/T:System.IDisposable System.IDisposable] interface.  
</li><li>Call [http:/monodoc/M:System.IDisposable.Dispose Dispose] when finished with the resource. The implementation for <b>Dispose</b> does two things: 
<ol><li>dispose of the resource, and 
</li><li>call [http:/monodoc/M:System.GC.SuppressFinalize GC.SuppressFinalize] . 
</li></ol>
</li></ul>
<p><b>SuppressFinalize</b> informs the GC that the object's finalizer doesn't need to be invoked, allowing the object to be freed during the first collection, and not after a considerable delay.  
A sample implementation is: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #008080; font-style: italic;">// for IntPtr, IDisposable</span>
 <span style="color: #0600FF; font-weight: bold;">using</span> <span style="color: #008080;">System</span><span style="color: #008000;">;</span>
&#160;
 <span style="color: #008080; font-style: italic;">// for HandleRef, DllImport</span>
 <span style="color: #0600FF; font-weight: bold;">using</span> <span style="color: #008080;">System.Runtime.InteropServices</span><span style="color: #008000;">;</span>
&#160;
 <span style="color: #0600FF; font-weight: bold;">sealed</span> <span style="color: #6666cc; font-weight: bold;">class</span> UnmanagedResource <span style="color: #008000;">:</span> IDisposable
 <span style="color: #008000;">&#123;</span>
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;...&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">private</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> IntPtr CreateResource <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008000;">&#91;</span>DllImport <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;...&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #0600FF; font-weight: bold;">private</span> <span style="color: #0600FF; font-weight: bold;">static</span> <span style="color: #0600FF; font-weight: bold;">extern</span> 
       <span style="color: #6666cc; font-weight: bold;">void</span> DeleteResource <span style="color: #008000;">&#40;</span>HandleRef handle<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// Use a HandleRef to avoid race conditions; </span>
    <span style="color: #008080; font-style: italic;">// see the GC-Safe P/Invoke Code section</span>
    <span style="color: #0600FF; font-weight: bold;">private</span> HandleRef _handle<span style="color: #008000;">;</span>
&#160;
    <span style="color: #0600FF; font-weight: bold;">public</span> UnmanagedResource <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
       IntPtr h <span style="color: #008000;">=</span> CreateResource <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
       _handle <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> HandleRef <span style="color: #008000;">&#40;</span><span style="color: #0600FF; font-weight: bold;">this</span>, h<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// Provide access to 3rd party code</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> HandleRef Handle <span style="color: #008000;">&#123;</span>
       <span style="color: #0600FF; font-weight: bold;">get</span> <span style="color: #008000;">&#123;</span><span style="color: #0600FF; font-weight: bold;">return</span> _handle<span style="color: #008000;">;</span><span style="color: #008000;">&#125;</span>
    <span style="color: #008000;">&#125;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// Dispose of the resource</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">void</span> Dispose <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
       Cleanup <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
       <span style="color: #008080; font-style: italic;">// Prevent the object from being placed on the </span>
       <span style="color: #008080; font-style: italic;">// finalization queue</span>
       <span style="color: #000000;">System</span><span style="color: #008000;">.</span><span style="color: #0000FF;">GC</span><span style="color: #008000;">.</span><span style="color: #0000FF;">SuppressFinalize</span> <span style="color: #008000;">&#40;</span><span style="color: #0600FF; font-weight: bold;">this</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// Finalizer provided in case Dispose isn't called.</span>
    <span style="color: #008080; font-style: italic;">// This is a fallback mechanism, but shouldn't be </span>
    <span style="color: #008080; font-style: italic;">// relied upon (see previous discussion).</span>
    ~UnmanagedResource <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
       Cleanup <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// Really dispose of the resource</span>
    <span style="color: #0600FF; font-weight: bold;">private</span> <span style="color: #6666cc; font-weight: bold;">void</span> Cleanup <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
       DeleteResource <span style="color: #008000;">&#40;</span>Handle<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
       <span style="color: #008080; font-style: italic;">// Don't permit the handle to be used again.</span>
       _handle <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> HandleRef <span style="color: #008000;">&#40;</span><span style="color: #0600FF; font-weight: bold;">this</span>, IntPtr<span style="color: #008000;">.</span><span style="color: #0000FF;">Zero</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>Frequently <b>IDisposable</b> examples will provide a virtual <tt>Dispose(bool)</tt> method, which both <b>Dispose</b> and the finalizer delegate to, as opposed to the <tt>Cleanup()</tt> method used above. However, providing both a a virtual function and a non-<tt>sealed</tt> class is advertising the ability/desire to subclass, which is a potentially bad idea. 
</p><p>It's a potentially bad idea, again, because of the garbage collector. When an object is promoted a GC generation, <i>all</i> objects it refers to are <i>also</i> promoted a generation, recursively. So if your finalizable object contains an <b>ArrayList</b> of other objects, both the <b>ArrayList</b>, all objects it contains, and all objects <i>those</i> objects reference (recursively) will be promoted. This can be a potentially large amount of managed memory which is promoted a generation. 
</p><p>Given the GC promotion rules, it is highly recommended that finalizable classes be "leaf" nodes; that is, objects that don't refer to other objects within the managed memory "tree". For this reason, it is highly suggested that finalizable objects be sealed to prevent subclassing, to minimize the number of managed objects that the finalizable object refers to. Rico Mariani discusses this in "Almost-rule #2: Never have finalizers".
</p><p>Implementing the <b>IDisposable</b> interface isn't a complete solution, as it requires that users remember to invoke the <b>Dispose</b> method. The C# <i>using</i> block can be used to ensure that <b>Dispose</b> is invoked at the end of the block: 
</p>
<pre class="csharp" style="font-family:monospace;"> <span style="color: #0600FF; font-weight: bold;">using</span> <span style="color: #008000;">&#40;</span>UnmanagedResource ur <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> UnmanagedResource<span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#123;</span>
    <span style="color: #008080; font-style: italic;">// Use the unmanaged resource.  It will be automatically</span>
    <span style="color: #008080; font-style: italic;">// disposed of at the end of this block.</span>
 <span style="color: #008000;">&#125;</span></pre>
<p>See also:
</p>
<ul><li><a href="http://blogs.msdn.com/ricom/archive/2003/12/02/40780.aspx" class="external text" rel="nofollow">Rico Mariani's Blog: Two things to avoid for better memory usage</a>.
</li></ul>
<h1> <span class="mw-headline" id="Miscellaneous_Topics"> Miscellaneous Topics </span></h1>
<p>Topics that didn't seem to fit in anywhere else, but might be useful. 
</p>
<h2> <span class="mw-headline" id="Meaning_of_.22Unsafe.22"> Meaning of "Unsafe" </span></h2>
<p>A "problem" is that "unsafe" is an overloaded term. It can refer to the use of the "unsafe" C# keyword, and it can be used as "anything that isn't safe", which may not require the "unsafe" keyword. 
</p><p>So, "unsafe" can mean (a) C# keyword; (b) violates .NET type system (similar to (a)); (c) may be insecure (reading files from a web client); (d) capable of causing a segfault. There are likely other meanings people can dream up as well. Note that (d) doesn't imply (b), as far as .NET is concerned. The runtime could itself have a bug that generates a segfault, but this doesn't violate the type system. 
</p><p>IntPtr doesn't require a violation of the type system, as you can't get the address of a .NET object (unless you "pin" it, which would require the appropriate Security rights), and is thus principally useful for interacting with unmanaged code, which exists outside of the .NET type system. 
</p><p>Surely, this is pure semantics, but I can see the designers perspective. 
</p>
<h2> <span class="mw-headline" id="Security"> Security </span></h2>
<p>.NET has a highly flexible security system. You can't invoke DllImported functions unless your app has the appropriate security rights -- generally, that the app is running on the local machine. If you're running it from a network share, or from a web site (similar to Java Applets), then your app will get a SecurityException. 
</p><p>You can get lots of security exceptions for various things, actually. Opening files can generate a security exception, for example. 
</p><p>[http:/monodoc/T:System.Security.Permissions.SecurityPermission System.Security.Permissions.SecurityPermission] is needed with [http:/monodoc/F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode SecurityPermissionFlag.UnmanagedCode] specified in order to perform a P/Invoke. 
</p><p>Programs can't specify this permission; they can only request it (or demand it, and if they can't get it, a SecurityException is thrown). 
</p><p>Administrators are the people who specify what permissions an application actually receives. 
</p><p>That's about the limits of my knowledge -- Security isn't my forte. You might find the following topics interesting. 
</p>
<ul><li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconrequestingpermissions.asp" class="external text" rel="nofollow">Requesting Permissions at MSDN</a>   
</li><li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconsecuritysyntax.asp" class="external text" rel="nofollow">Security Syntax at MSDN</a>   
</li><li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconcodeaccesssecurity.asp" class="external text" rel="nofollow">Code Access Security at MSDN</a>   
</li><li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconinheritancedemands.asp" class="external text" rel="nofollow">Inheritance Demands at MSDN</a>   
</li></ul>
<p>See also: <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/csspec/html/vclrfcsharpspec_A_2.asp" class="external text" rel="nofollow">Unsafe Code at MSDN</a>   
</p>
<h1> <span class="mw-headline" id="Troubleshooting"> Troubleshooting </span></h1>
<p>In Unix, sometimes P/Invoking a library can fail due to a number of reasons:
</p>
<ul><li> The Library being P/Invoked not being in the LD_LIBRARY_PATH
</li><li> The Library being P/Invoked has a different name
</li><li> The library being P/Invoked has different casing (MONO_IOMAP does not apply here)
</li><li> The library could depend on symbols from another library that has not been loaded.
</li></ul>
<p>To identify the source of the problem if you get an error in your P/Invoke run Mono like this:
</p>
<pre class="bash" style="font-family:monospace;"><span style="color: #666666;">bash$ </span><span style="color: #007800;">MONO_LOG_LEVEL</span>=<span style="color: #ff0000;">&quot;debug&quot;</span> <span style="color: #007800;">MONO_LOG_MASK</span>=<span style="color: #ff0000;">&quot;dll&quot;</span> mono glue.exe</pre>
<h1> <span class="mw-headline" id="Commentary"> Commentary </span></h1>
<p>Interesting commentary that doesn't really belong elsewhere, but is still good to know. 
</p>
<h2> <span class="mw-headline" id="P.2FInvoke_Specification"> P/Invoke Specification </span></h2>
<p>From Paolo Molaro:  
</p>
<dl><dd> Yes, the P/Invoke specification (or lack thereof) is a mess. It was done by people that didn't [think] through the portability issues and this is probably one of the reasons the MS CLR is not really supported on 9x-based platforms. Note: P/Invoke is intrinsically non-portable, the main issue is that P/Invoke is poorly defined in a non-win32 system. Think of Charset: they allow Ansi and Unicode (with Auto meaning one or the other according to the platform), but the world uses also other encodings. At the very least they should have added a Charset.Encoding or something, with the actual encoding specified separately as a string, for example (good luck, though, finding a UCS4 encoding implementation in the base assemblies...).
</dd></dl>
<h1> <span class="mw-headline" id="Thanks"> Thanks </span></h1>
<p>Portions of this document were generated as a result of a mono-list discussion between Jonathan Pryor and David Jeske. See: <a href="http://lists.ximian.com/archives/public/mono-list/2003-July/014886.html" class="external free" rel="nofollow">http://lists.ximian.com/archives/public/mono-list/2003-July/014886.html</a> . 
</p><p>Thanks also to Paolo Molaro, Bernie Solomon, and Marcus for reviews and comments. 
</p>
<h1> <span class="mw-headline" id="Copyright"> Copyright </span></h1>
<p>To the greatest extent possible, this document is dedicated to the Public Domain. Please properly document <a href="mailto:jonpryor@vt.edu" class="external text" rel="nofollow">Jonathan Pryor</a> as the original author (you don't go quoting Mark Twain without mentioning him even though his works are all Public Domain), but I fully expect that this document can (and will) be massaged for other mediums. 
</p><p>Note that some portions of this document are quotations from others; the original author is mentioned when quotations are made. 
</p>
<h1> <span class="mw-headline" id="Revision_History"> Revision History </span></h1>
<dl><dt> August 15, 2005</dt><dd> Added char** marshalling tutorial
</dd></dl>
<dl><dt> April 12, 2005&#160;</dt><dd> Moved into the wiki.
</dd></dl>
<dl><dt> February 3, 2005 &#160;</dt><dd> Revised navigation menu to show 1st and 2nd level links. Documented Mono's __Internal library name extension for importing symbols from within the loading program. Added Marshaling Arrays section, which clarifies array marshaling issues and includes the David Jesk commentary (which shouldn't have been in the "Avoiding Marshaling" section anyway). Added boolean marshaling information. Added Marshaling Embedded Strings information. Minor corrections, additional links to blogs and articles.
</dd></dl>
<dl><dt> June 14, 2004 &#160;</dt><dd> Added Properly Disposing of Resources section; changed title to clarify document's intent.
</dd></dl>
<dl><dt> June 6, 2004&#160;</dt><dd> Mono properly frees the memory of class-typed return values now. Remove comment stating otherwise. (miguel)
</dd></dl>
<dl><dt> May 15, 2004&#160;</dt><dd> Added Exception Propogation section, updated Mono's .config file handling; spelling correction: s/marshalling/marshaling/g (this matches MSDN spelling conventions).
</dd></dl>
<dl><dt> March 20, 2004&#160;</dt><dd> Added Memory Boundaries section based on suggestions from Marcus; formatting changes.
</dd></dl>
<dl><dt> August-October 2003 &#160;</dt><dd> Initial Version.
</dd></dl>

