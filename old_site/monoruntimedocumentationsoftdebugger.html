---
layout: obsolete
title: "Mono:Runtime:Documentation:SoftDebugger"
permalink: /old_site/Mono:Runtime:Documentation:SoftDebugger/
redirect_from:
  - /Mono:Runtime:Documentation:SoftDebugger/
  - /Soft_Debugger/
---

<h1>Mono:Runtime:Documentation:SoftDebugger</h1>

<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Table of contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Soft-Mode_Debugger"><span class="tocnumber">1</span> <span class="toctext">Soft-Mode Debugger</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Architecture"><span class="tocnumber">1.1</span> <span class="toctext">Architecture</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="#Debugger_Agent"><span class="tocnumber">1.1.1</span> <span class="toctext">Debugger Agent</span></a></li>
<li class="toclevel-3 tocsection-4"><a href="#Wire_Protocol"><span class="tocnumber">1.1.2</span> <span class="toctext">Wire Protocol</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="#Client_library"><span class="tocnumber">1.1.3</span> <span class="toctext">Client library</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-6"><a href="#Implementation"><span class="tocnumber">1.2</span> <span class="toctext">Implementation</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#Agent"><span class="tocnumber">1.2.1</span> <span class="toctext">Agent</span></a>
<ul>
<li class="toclevel-4 tocsection-8"><a href="#Design"><span class="tocnumber">1.2.1.1</span> <span class="toctext">Design</span></a></li>
<li class="toclevel-4 tocsection-9"><a href="#The_debugger_thread"><span class="tocnumber">1.2.1.2</span> <span class="toctext">The debugger thread</span></a></li>
<li class="toclevel-4 tocsection-10"><a href="#Event_handling"><span class="tocnumber">1.2.1.3</span> <span class="toctext">Event handling</span></a></li>
<li class="toclevel-4 tocsection-11"><a href="#Suspend.2FResume"><span class="tocnumber">1.2.1.4</span> <span class="toctext">Suspend/Resume</span></a></li>
<li class="toclevel-4 tocsection-12"><a href="#Sequence_points"><span class="tocnumber">1.2.1.5</span> <span class="toctext">Sequence points</span></a></li>
<li class="toclevel-4 tocsection-13"><a href="#Single_Stepping"><span class="tocnumber">1.2.1.6</span> <span class="toctext">Single Stepping</span></a></li>
<li class="toclevel-4 tocsection-14"><a href="#Breakpoints"><span class="tocnumber">1.2.1.7</span> <span class="toctext">Breakpoints</span></a></li>
<li class="toclevel-4 tocsection-15"><a href="#AOT_support"><span class="tocnumber">1.2.1.8</span> <span class="toctext">AOT support</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</td></tr></table>
<h1> <span class="mw-headline" id="Soft-Mode_Debugger"> Soft-Mode Debugger </span></h1>
<p>The Mono Soft Debugger is a new debugging framework for Mono.   Unlike regular debuggers which act as all-knowing and controlling programs that control a separate process, the Mono Soft Debugger is actually a cooperative debugger that is built into the Mono runtime.
</p><p>Applications communicate with the Mono runtime and request debugging operations to be performed on the target process.
</p><p><br />
The Mono Soft Debugger first became available with Mono 2.6 and is primarily used today with <a href="http://monotouch.net" class="external text" rel="nofollow">Mono on the iPhone</a> and is used from the <a href="http://monodevelop.com" class="external text" rel="nofollow">MonoDevelop IDE</a>.
</p>
<h2> <span class="mw-headline" id="Architecture"> Architecture </span></h2>
<p>The following diagram is useful in the discussion of the soft debugger:
</p><p><a href="{{site.github.url}}/images/old_site/2/2a/0911030528Mp6F5SHL.png" class="image"><img alt="0911030528Mp6F5SHL.png" src="{{site.github.url}}/images/old_site/2/2a/0911030528Mp6F5SHL.png" width="579" height="374" /></a>
</p><p>The soft debugger lives inside the Mono runtime.   Debuggers communicate with this component with a compact protocol over a socket connection.    For ease of use the protocol has been encapsulated in the Mono.Debugger.Soft.dll API which different IDEs can use to communicate with the target.
</p><p>The soft debugger work both with Just-in-Time compiled code, and with <a href="{{site.github.url}}/old_site/AOT" title="AOT">batch compiled code</a> allowing it to debug both regular Mono applications on a desktop, or applications on devices like the iPhone or the <a href="{{site.github.url}}/old_site/Mono:PlayStation3" title="Mono:PlayStation3">PlayStation 3</a>.
</p>
<h3> <span class="mw-headline" id="Debugger_Agent"> Debugger Agent </span></h3>
<p>The debugger agent is a module inside the mono runtime which offers debugging
services to client programs.
</p>
<h3> <span class="mw-headline" id="Wire_Protocol"> Wire Protocol </span></h3>
<p>Clients communicate with the agent using a wire protocol over a socket transport.   Read our <a href="{{site.github.url}}/old_site/SoftDebugger:WireFormat" title="SoftDebugger:WireFormat">Soft Debugger Wire Protocol</a> document for details about the protocol.   
</p><p>The wire protocol is inspired by the <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jpda/jdwp-spec.html" class="external text" rel="nofollow">Java Debug Wire Protocol</a>.
</p>
<h3> <span class="mw-headline" id="Client_library"> Client library </span></h3>
<p>The client library is a C# assembly which uses the wire protocol to communicate
with the debugger agent running inside the mono runtime. It is based on the <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jpda/jdi/" class="external text" rel="nofollow">Java Debug Interface</a>. The
assembly is named Mono.Debugger.Soft.dll, and its source is in mcs/class/Mono.Debugger.Soft.
</p>
<h2> <span class="mw-headline" id="Implementation"> Implementation </span></h2>
<h3> <span class="mw-headline" id="Agent"> Agent </span></h3>
<p>The source code is in mini/debugger-agent.{h,c}. Unlike the JDWP agent in Java,
the debugger agent is tightly integrated with the mono runtime because mono doesn't have a tool interface with similar capabilities as JVMTI in Java.
</p>
<h4> <span class="mw-headline" id="Design"> Design </span></h4>
<p>The design for the agent was to choose solutions which were easy to implement, they can be improved later. This means that some things like step out/over can be very slow, the code generated by the JIT when debugging is enabled is larger/slower etc.
</p>
<h4> <span class="mw-headline" id="The_debugger_thread"> The debugger thread </span></h4>
<p>The agent starts its own thread which it uses to communicate with clients using
the wire protocol.
</p>
<h4> <span class="mw-headline" id="Event_handling"> Event handling </span></h4>
<p>On startup, the agent registers callbacks for events using the mono profiler
interface. When a callback is called, it searches the list of event requests
for a request matching the event type. If one is found, the event is sent to
the client using the wire protocol.
</p>
<h4> <span class="mw-headline" id="Suspend.2FResume"> Suspend/Resume </span></h4>
<p>Suspending/Resuming the runtime is the most complex part of the debugger agent. There are many complications:
- threads running managed code/native code/transitioning between the two.
- threads starting up/terminating.
- multiple suspend/resume operations happening in parallel.
</p><p>Threads running native code can't be suspended, because they can hold locks which are needed by the debugger and the rest of the runtime to function. So
they are left running, and are only suspended when they enter managed code. We save enough state at managed-&gt;native transitions to be able to produce stack traces and examine the state of stack frames. However, debugger invocations are not supported on threads which are running managed code, so property evaluation is not possible on these threads.
</p><p>A suspend can be started by a normal runtime thread when it receives an event which asks for the runtime to suspend, or it can be started by the debugger thread in response to a VM.Suspend command. In contrast, a resume
can only be started by the debugger thread in response to a VM.Resume command.
</p><p>Threads running managed code are suspended by turning on single stepping, and suspending the thread when it reaches the single step event handler. Threads running native code are treated as suspended.
</p><p>A suspend can be started by calling suspend_vm (), which is an async operation.
This means that when the client receives an event, the runtime might not be
entirely suspended yet, so code which needs the runtime to be suspended like
the stack frame processing code needs to call wait_for_suspend (). After starting a suspend, the thread needs to suspend itself by calling suspend_current ().
</p>
<h4> <span class="mw-headline" id="Sequence_points"> Sequence points </span></h4>
<p>A sequence point is an IL offset where the program can be stopped and its
state can be examined. Currently the debugger determines sequence points automatically. A sequence point is placed at the places:
</p>
<ul><li> IL offsets where the IL stack is empty. This generally corresponds to the end of C# statements.
</li><li> IL offsets which contain the NOP IL instructions. This can be used by a compiler to insert extra sequence points, like between nested calls.
</li><li> IL offsets which have a corresponding line number entry in the .mdb file.
</li></ul>
<p>The mdbdump tool in mcs/tools/mdbdump can be used to examine the line number tables inside an .mdb file.
</p><p>A sequence point is represented by the JIT opcode OP_SEQ_POINT. The JIT backends generate code from this opcode which implements single stepping/breakpoints.
</p>
<h4> <span class="mw-headline" id="Single_Stepping"> Single Stepping </span></h4>
<p>The implementation of single stepping is target specific. On most platforms, it is implemented by allocating a memory page and having the implementation of
OP_SEQ_POINT read from that page. Single stepping is then turned on by read-protecting that page, causing the memory read to turn into a SIGSEGV or similar signal. The signal handler needs to determine whenever the signal was caused by access to this page, and if it is, transfer control to the single step handler code in the debugger agent.
</p><p>Step over/out is implemented by single stepping repeatedly until the condition becomes true (i.e. we reach a different line/parent frame).
</p>
<h4> <span class="mw-headline" id="Breakpoints"> Breakpoints </span></h4>
<p>Breakpoints are usually implemented similarly to single stepping, by reading from a memory page. OP_SEQ_POINT generates a few nops to act as a placeholder,
then the code to read from the trigger page is written to the JITted code when
the breakpoint is enabled, and changed back to nops when the breakpoint is disabled.
</p>
<h4> <span class="mw-headline" id="AOT_support"> AOT support </span></h4>
<p>AOTed code can be debugged by compiling it with the 'soft-debug' aot option, i.e:
mono --debug --aot=soft-debug foo.dll
</p><p>In the AOT case, the code can'be be patched at runtime, so breakpoints are implemented by reading from per-method table with one entry per sequence point, which is either NULL or points to the breakpoint trigger page.
</p>
