---
layout: obsolete
title: "MonoMac/Documentation/Binding New Objective-C Types"
permalink: /old_site/MonoMac/Documentation/Binding_New_Objective-C_Types/
---

<h1>MonoMac/Documentation/Binding New Objective-C Types</h1>

<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Binding_Objective-C_Types"><span class="tocnumber">1</span> <span class="toctext">Binding Objective-C Types</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Binding_an_API"><span class="tocnumber">1.1</span> <span class="toctext">Binding an API</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#The_API_definition_file"><span class="tocnumber">1.2</span> <span class="toctext">The API definition file</span></a>
<ul>
<li class="toclevel-3 tocsection-4"><a href="#Binding_Methods"><span class="tocnumber">1.2.1</span> <span class="toctext">Binding Methods</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="#Binding_Properties"><span class="tocnumber">1.2.2</span> <span class="toctext">Binding Properties</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#Binding_Constructors"><span class="tocnumber">1.2.3</span> <span class="toctext">Binding Constructors</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Binding_Protocols"><span class="tocnumber">1.2.4</span> <span class="toctext">Binding Protocols</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Binding_Class_Extensions."><span class="tocnumber">1.2.5</span> <span class="toctext">Binding Class Extensions.</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#"><span class="tocnumber">1.2.6</span> <span class="toctext"></span></a></li>
<li class="toclevel-3 tocsection-10"><a href="#Type_mappings"><span class="tocnumber">1.2.7</span> <span class="toctext">Type mappings</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#Arrays"><span class="tocnumber">1.2.8</span> <span class="toctext">Arrays</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="#Selectors"><span class="tocnumber">1.2.9</span> <span class="toctext">Selectors</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#Memory_management_attributes"><span class="tocnumber">1.2.10</span> <span class="toctext">Memory management attributes</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#Style_Guidelines"><span class="tocnumber">1.2.11</span> <span class="toctext">Style Guidelines</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Using_.5BInternal.5D"><span class="tocnumber">1.2.12</span> <span class="toctext">Using [Internal]</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="#Event_Handlers_and_Callbacks"><span class="tocnumber">1.3</span> <span class="toctext">Event Handlers and Callbacks</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Enumerations_and_Base_Types"><span class="tocnumber">1.4</span> <span class="toctext">Enumerations and Base Types</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#out.2Fref_parameters"><span class="tocnumber">1.5</span> <span class="toctext">out/ref parameters</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Binding_Objective-C_Argument_Lists"><span class="tocnumber">1.6</span> <span class="toctext">Binding Objective-C Argument Lists</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Binding_Fields"><span class="tocnumber">1.7</span> <span class="toctext">Binding Fields</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Binding_Blocks"><span class="tocnumber">1.8</span> <span class="toctext">Binding Blocks</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#Linking_the_Dependencies"><span class="tocnumber">1.9</span> <span class="toctext">Linking the Dependencies</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#Assisted_References"><span class="tocnumber">1.10</span> <span class="toctext">Assisted References</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#Inheriting_Protocols"><span class="tocnumber">1.11</span> <span class="toctext">Inheriting Protocols</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h1> <span class="mw-headline" id="Binding_Objective-C_Types">Binding Objective-C Types</span></h1>
<p>This document describes how to bind Objective-C APIs, if you are binding just C APIs, you should use the standard .NET mechanism for this, <a href="{{site.baseurl}}/Dllimport" title="Dllimport" class="mw-redirect">the P/Invoke framework</a>. Details on how to statically link a C library are available on the <a href="/index.php?title=MonoMac/Documentation/Linking_Native_Libraries&amp;action=edit&amp;redlink=1" class="new" title="MonoMac/Documentation/Linking Native Libraries (page does not exist)">Linking Native Libraries</a> page.
</p><p>If you would rather bind the API manually, see the <a href="{{site.baseurl}}/MonoMac/Documentation/Binding_New_Objective-C_Types/Binding_Details" title="MonoMac/Documentation/Binding New Objective-C Types/Binding Details">Binding Details</a> page.
</p>
<h2> <span class="mw-headline" id="Binding_an_API">Binding an API</span></h2>
<p>To do a comprehensive binding, you will want to understand the Objective-C API definition and familiarize yourself with the .NET Framework Design Guidelines.
</p><p>The new <b>bmac</b> tool simplifies binding an Objective-C API and does the heavy lifting for you: registering the selectors, taking care of invoking the proper handle for overwritten classes, doing parameter checking and doing some of the common marshaling required for your project.
</p><p>To bind your library you will typically start with an API definition file. An API definition file is merely a C# source file that contains interfaces that have been annotated with a handful of attributes that help drive the binding.
</p><p>For example, this is a trivial api file for a library:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #0600FF; font-weight: bold;">using</span> <span style="color: #008080;">MonoMac.Foundation</span><span style="color: #008000;">;</span>
&#160;
<span style="color: #0600FF; font-weight: bold;">namespace</span> Cocos2D <span style="color: #008000;">&#123;</span>
    <span style="color: #008000;">&#91;</span>BaseType <span style="color: #008000;">&#40;</span><a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a> <span style="color: #008000;">&#40;</span>NSObject<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #6666cc; font-weight: bold;">interface</span> Camera <span style="color: #008000;">&#123;</span>
        <span style="color: #008000;">&#91;</span><span style="color: #0600FF; font-weight: bold;">Static</span>, Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;getZEye&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
        <span style="color: #6666cc; font-weight: bold;">float</span> ZEye <span style="color: #008000;">&#123;</span> <span style="color: #0600FF; font-weight: bold;">get</span><span style="color: #008000;">;</span> <span style="color: #008000;">&#125;</span>
&#160;
        <span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;restore&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
        <span style="color: #6666cc; font-weight: bold;">void</span> Restore <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
        <span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;locate&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
        <span style="color: #6666cc; font-weight: bold;">void</span> Locate <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
        <span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;setEyeX:eyeY:eyeZ:&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
        <span style="color: #6666cc; font-weight: bold;">void</span> SetEyeXYZ <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">float</span> x, <span style="color: #6666cc; font-weight: bold;">float</span> y, <span style="color: #6666cc; font-weight: bold;">float</span> z<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
        <span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;setMode:&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
        <span style="color: #6666cc; font-weight: bold;">void</span> SetMode <span style="color: #008000;">&#40;</span>CameraMode mode<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
<span style="color: #008000;">&#125;</span></pre>
<p>The above sample defines a class called Cocos2D.Camera that derives from the NSObject base type (this type comes from MonoMac.Foundation.NSObject) and which defines a static property (ZEye), two methods that take no arguments and a method that takes three arguments.
</p><p>An in-depth discussion of the format of the API file and the attributes is covered in the <a href="#The_API_definition_file">API definition file</a> section below.
</p><p>To produce a complete binding, you will typically deal with three sets of sources:
</p>
<ul><li> The API definition file.
</li><li> Optional: any enums, types, structs required by the API definition file.
</li><li> Optional: extra sources that might expand the generated binding, or provide a more C# friendly API.
</li></ul>
<p>The API Definition file: will only contain namespaces and interface definitions (with any members that an interface can contain) and should not contain classes, enumerations, delegates or structs. The API definition file is merely the contract that will be used to generate the API.
</p><p>Any extra code that you need like enumerations or supporting classes should be hosted on a separate file, in the example above the "CameraMode" is an enumeration value that does not exist in the .cs file and should be hosted in a separate file, for example "enums.cs":
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">enum</span> CameraMode <span style="color: #008000;">&#123;</span>
    FlyOver, Back, Follow <span style="color: #008000;">&lt;/</span>pre<span style="color: #008000;">&gt;</span>
<span style="color: #008000;">&#125;</span></pre>
<p>The extra sources file typically contains event definitions, or contains code that is not handled directly by the generator. Each class produced by the generator from the API definition file is a partial class, so you can extend the class with new methods like this:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">partial</span> <span style="color: #6666cc; font-weight: bold;">class</span> Camera <span style="color: #008000;">&#123;</span>
    <span style="color: #008080; font-style: italic;">// Provide a ToString method</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">override</span> <span style="color: #6666cc; font-weight: bold;">string</span> ToString <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
         <span style="color: #0600FF; font-weight: bold;">return</span> <span style="color: #6666cc; font-weight: bold;">String</span><span style="color: #008000;">.</span><span style="color: #0000FF;">Format</span> <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;ZEye: {0}&quot;</span>, ZEye<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
<span style="color: #008000;">&#125;</span></pre>
<p>Now we will build the API into a library that we can use in our solution. From the shell execute the following command:
</p>
<pre class="bash" style="font-family:monospace;"><span style="color: #666666;">bash$ </span>bmac cocos2d.cs -s:enums.cs extensions.cs</pre>
<p>The above command will generate the file cocos2d.dll in the current directory, and it will contain the fully bound library that you can use in your project.
</p><p>Sometimes you might find that you need a few enumeration values, delegate definitions or other types. Do not place those in the API definitions file, as this is merely a contract 
</p>
<h2> <span class="mw-headline" id="The_API_definition_file">The API definition file</span></h2>
<p>The API definition file consists of a number of interfaces. The interfaces in the API definition will be turned into a class declaration and they must be decorated with the [BaseType] attribute to specify the base class for the class.
</p><p>You might be wondering why we did not use classes instead of interfaces for the contract definition. We picked interfaces because it allowed us to write the contract for a method without having to supply a method body in the API definition file, or having to supply a body that had to throw an exception or return a meaningful value.
</p><p>But since we are using the interface as a skeleton to generate a class we had to resort to decorating various parts of the contract with attributes to drive the binding.
</p>
<h3> <span class="mw-headline" id="Binding_Methods">Binding Methods</span></h3>
<p>The simplest binding you can do is to bind a method. Just declare a method in the interface with the C# naming conventions and decorate the method with the [Export] attribute. The [Export] attribute is what links your C# name with the Objective-C name in the MonoMac runtime. The parameter of the Export attribute is the name of the Objective-C selector, some examples:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008080; font-style: italic;">// A method, that takes no arguments</span>
<span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;refresh&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">void</span> Refresh <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
<span style="color: #008080; font-style: italic;">// A method that takes two arguments and return the result</span>
<span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;add:and:&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">int</span> <span style="color: #0600FF; font-weight: bold;">Add</span> <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">int</span> a, <span style="color: #6666cc; font-weight: bold;">int</span> b<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
<span style="color: #008080; font-style: italic;">// A method that takes a string</span>
<span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;draw:atColumn:andRow:&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">void</span> Draw <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">string</span> text, <span style="color: #6666cc; font-weight: bold;">int</span> column, <span style="color: #6666cc; font-weight: bold;">int</span> row<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<p>The above samples show how you can bind instance methods. To bind static methods, you must use the [Static] attribute, like this:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008080; font-style: italic;">// A static method, that takes no arguments</span>
<span style="color: #008000;">&#91;</span><span style="color: #0600FF; font-weight: bold;">Static</span>, Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;refresh&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">void</span> Beep <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<p>This is required because the contract is part of an interface, and interfaces have no notion of static vs instance declarations, so it is necessary once again to resort to attributes. If you want to hide a particular method from the binding, you can decorate the method with the [Internal] attribute.
</p><p>The bmac command will introduce checks for reference parameters to not be null. If you want to allow null values for a particular parameter, use the [NullAllowed] attribute on the parameter, like this:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;setText:&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">string</span> SetText <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#91;</span>NullAllowed<span style="color: #008000;">&#93;</span> <span style="color: #6666cc; font-weight: bold;">string</span> text<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<p>When exporting a reference type, with the [Export] keyword you can also specify the allocation semantics. This is necessary to ensure that no data is leaked: TODO DOCUMENT.
</p>
<h3> <span class="mw-headline" id="Binding_Properties">Binding Properties</span></h3>
<p>Just like methods, Objective-C properties are bound using the [Export] attribute and map directly to C# properties. Just like methods, properties can be decorated with the [Static] and the [Internal] attributes.
</p><p>When you use the [Export] attribute on a property under the covers bmac actually binds two methods: the getter and the setter. The name that you provide to export is the basename and the the setter is computed by prepending the word "set", turning the first letter of the basename into upper case and making the selector take an argument. This means that [Export ("label")] applied on a property actually binds the "label" and "setLabel:" Objective-C methods.
</p><p>Sometimes the Objective-C properties do not follow the pattern described above and the name is manually overwritten. In those cases you can control the way that the binding is generated by using the [Bind] attribute on the getter or setter, for example:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;menuVisible&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">bool</span> MenuVisible <span style="color: #008000;">&#123;</span> <span style="color: #008000;">&#91;</span>Bind <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;isMenuVisible&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span> <span style="color: #0600FF; font-weight: bold;">get</span><span style="color: #008000;">;</span> <span style="color: #0600FF; font-weight: bold;">set</span><span style="color: #008000;">;</span> <span style="color: #008000;">&#125;</span></pre>
<p>This then binds "isMenuVisible" and "setMenuVisible:".
</p><p>Just like methods allow some parameters to be flagged with [NullAllowed], you can apply [NullAllowed] to a property to indicate that null is a valid value for the property, for example:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;text&quot;</span><span style="color: #008000;">&#41;</span>, NullAllowed<span style="color: #008000;">&#93;</span> 
<span style="color: #6666cc; font-weight: bold;">string</span> Text <span style="color: #008000;">&#123;</span> <span style="color: #0600FF; font-weight: bold;">get</span><span style="color: #008000;">;</span> <span style="color: #0600FF; font-weight: bold;">set</span><span style="color: #008000;">;</span> <span style="color: #008000;">&#125;</span></pre>
<p>The [NullAllowed] parameter can also be specified directly on the setter:
[Export ("text")] 
string Text { get; [NullAllowed] set; }
&lt;/csharp&gt;
</p>
<h3> <span class="mw-headline" id="Binding_Constructors">Binding Constructors</span></h3>
<p>The <b>bmac</b> tool will automatically generate fours constructors in your class, for a given class <i>Foo</i>, it generates:
</p>
<blockquote>
<dl><dt> Foo ()
</dt><dd> the default constructor (maps to Objective-C's "init" constructor)
</dd><dt>Foo (NSCoder)
</dt><dd> the constructor used during deserialization of NIB files (maps to Objective-C's "initWithCoder:" constructor).
</dd><dt>Foo (IntPtr handle)
</dt><dd> the constructor for handle-based creation, this is invoked by the runtime when the runtime needs to expose a managed object from an unmanaged object.
</dd><dt>Foo (NSEmptyFlag)
</dt><dd> this is used by derived classes to prevent double initialization.
</dd></dl>
</blockquote>
<p>For constructors that you define, they need to be declared using the following signature inside the Interface definition: they must return an IntPtr value and the name of the method should be Constructor. For example to bind the initWithFrame: constructor, this is what you would use:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;initWithFrame:&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
IntPtr Constructor <span style="color: #008000;">&#40;</span>RectangleF frame<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<h3> <span class="mw-headline" id="Binding_Protocols">Binding Protocols</span></h3>
<p>As described in the API design document, in the section <a href="{{site.baseurl}}/MonoMac/Documentation/API#Models" title="MonoMac/Documentation/API">discussing Models and Protocols</a>, MonoMac maps the Objective-C protocols into classes that have been flagged with the [Model] attribute. This is typically used when implementing Objective-C delegate classes.
</p><p>The big difference between a regular bound class and a delegate class is that the delegate class might have one or more optional methods.
</p><p>For example consider the UIKit class UIAccelerometerDelegate, this is how it is bound in MonoMac:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>BaseType <span style="color: #008000;">&#40;</span><a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a> <span style="color: #008000;">&#40;</span>NSObject<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #008000;">&#91;</span>Model<span style="color: #008000;">&#93;</span>
<span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">interface</span> NSTextStorageDelegate <span style="color: #008000;">&#123;</span>
    <span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;textStorageWillProcessEditing:&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #6666cc; font-weight: bold;">void</span> TextStorageWillProcessEditing <span style="color: #008000;">&#40;</span>NSNotification notification<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;textStorageDidProcessEditing:&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #6666cc; font-weight: bold;">void</span> TextStorageDidProcessEditing <span style="color: #008000;">&#40;</span>NSNotification notification<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
<span style="color: #008000;">&#125;</span></pre>
<p>Since this is an optional method on the definition for <i>NSTextStorageDelegate</i> there is nothing else to do. But if there was a required method on the protocol, you should add the [Abstract] attribute to the method. This will force the user of the implementation to actually provide a body for the method. 
</p><p>In general, protocols are used in classes that respond to messages. This is typically done in Objective-C by assigning to the "delegate" property an instance of an object that responds to the methods in the protocol.
</p><p>The convention in MonoMac is to support both the Objective-C loosely coupled style where any instance of an NSObject can be assigned to the delegate, and to also expose a strongly typed version of it. For this reason, we typically provide both a <i>Delegate</i> property that is strongly typed and a <i>WeakDelegate</i> that is loosely typed. We usually bind the loosely typed version with Export, and we use the [Wrap] attribute to provide the strongly typed version.
</p><p>This shows how we bound the NSTextStorage class:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>BaseType <span style="color: #008000;">&#40;</span><a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a> <span style="color: #008000;">&#40;</span>NSMutableAttributedString<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">interface</span> NSTextStorage <span style="color: #008000;">&#123;</span>
&#160;
    <span style="color: #008000;">&#91;</span>Wrap <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;WeakDelegate&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    NSTextStorageDelegate <span style="color: #6666cc; font-weight: bold;">Delegate</span> <span style="color: #008000;">&#123;</span> <span style="color: #0600FF; font-weight: bold;">get</span><span style="color: #008000;">;</span> <span style="color: #0600FF; font-weight: bold;">set</span><span style="color: #008000;">;</span> <span style="color: #008000;">&#125;</span>
&#160;
    <span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;delegate&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    NSObject WeakDelegate <span style="color: #008000;">&#123;</span> <span style="color: #0600FF; font-weight: bold;">get</span><span style="color: #008000;">;</span> <span style="color: #0600FF; font-weight: bold;">set</span><span style="color: #008000;">;</span> <span style="color: #008000;">&#125;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// other members omitted for brevity</span>
<span style="color: #008000;">&#125;</span></pre>
<h3> <span class="mw-headline" id="Binding_Class_Extensions.">Binding Class Extensions.</span></h3>
<p>In Objective-C it is possible to extend classes with new methods, similar in spirit to C#'s extension methods. When one of these methods is present, you can use the [Target] attribute to flag the first parameter of a method as being the receiver of the Objective-C message.
</p><p>For example, in MonoMac we bound the extension methods that are defined on NSString when UIKit is imported as methods in the UIView, like this:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>BaseType <span style="color: #008000;">&#40;</span><a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a> <span style="color: #008000;">&#40;</span>NSObject<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">interface</span> NSImage <span style="color: #008000;">&#123;</span>
&#160;
    <span style="color: #008000;">&#91;</span>Bind <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;drawInRect:withAttributes:&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #6666cc; font-weight: bold;">void</span> DrawInRect <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#91;</span>Target<span style="color: #008000;">&#93;</span> <span style="color: #6666cc; font-weight: bold;">string</span> str, RectangleF rect, NSDictionary attributes<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// other members omitted for brevity</span>
<span style="color: #008000;">&#125;</span></pre>
<h3> <span class="mw-headline" id=""> </span></h3>
<h3> <span class="mw-headline" id="Type_mappings">Type mappings</span></h3>
<p>The following table shows how you should map types from the Objective-C and CocoaTouch world to the MonoMac world:
</p>
<blockquote>
<table style="border-collapse: collapse; border-spacing: 1; border-width: 1px; border-style: solid">
<tr>
<th> Objective-C Type Name
</th>
<th> MonoMac Type
</th></tr>
<tr>
<td> CFTimeInterval
</td>
<td> double
</td></tr>
<tr>
<td> NSString
</td>
<td> string
</td></tr>
<tr>
<td> GCRect
</td>
<td> System.Drawing.RectangleF
</td></tr>
<tr>
<td> CGPoint
</td>
<td> System.Drawing.PointF
</td></tr>
<tr>
<td> CGSize
</td>
<td> System.Drawing.SizeF
</td></tr>
<tr>
<td> CGFloat
</td>
<td> float
</td></tr>
<tr>
<td> CoreFoundation types (CF*)
</td>
<td> <a href="http://docs.go-mono.com/MonoMac.CoreFoundation" class="external text" rel="nofollow">MonoMac.CoreFoundation</a>.CF*
</td></tr>
<tr>
<td> Foundation Types (NS*)
</td>
<td> <a href="http://docs.go-mono.com/MonoMac.Foundation" class="external text" rel="nofollow">MonoMac.Foundation</a>.NS*
</td></tr></table>
</blockquote>
<h3> <span class="mw-headline" id="Arrays">Arrays</span></h3>
<p>The MonoMac runtime automatically takes care of converting C# arrays to NSArrays and doing the conversion back, so for example the imaginary Objective-C method that returns an NSArray of NSViews:
</p>
<pre>
- NSArray *getPeerViews ();
</pre>
<p>Is bound like this:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>Export<span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;getPeerViews&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
UIView <span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span> GetPeerViews <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<p>Although you could always return NSObject [] as the return value, the array would not be strongly typed, and MonoDevelop would not be able to provide code completion for you, and you would have to cast the object to the real object later.
</p>
<h3> <span class="mw-headline" id="Selectors">Selectors</span></h3>
<h3> <span class="mw-headline" id="Memory_management_attributes">Memory management attributes</span></h3>
<p>When you use the [Export] attribute and you are passing data that will be retained by the called method, you can specify the argument semantics by passing it as a second parameter, for example:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;method&quot;</span>, ArgumentSemantic<span style="color: #008000;">.</span><span style="color: #0000FF;">Retain</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span></pre>
<p>The above would flag the value as having the "Retain" semantics. The semantics available are:
</p>
<blockquote>
<dl><dt>Assign
</dt><dt>Copy
</dt><dt>Retain
</dt></dl>
</blockquote>
<h3> <span class="mw-headline" id="Style_Guidelines">Style Guidelines</span></h3>
<h3> <span class="mw-headline" id="Using_.5BInternal.5D">Using [Internal]</span></h3>
<p>You can use the [Internal] attribute to hide a method from the public API. You might want to do this in cases where the exposed API is too low-level and you want to provide a high-level implementation in a separate file based on this method.
</p><p>You can also use this when you run into limitations in the binding generator, for example some advanced scenarios might expose types that are not bound and you want to bind in your own way, and you want to wrap those types yourself in your own way.
</p>
<h2> <span class="mw-headline" id="Event_Handlers_and_Callbacks">Event Handlers and Callbacks</span></h2>
<p>Objective-C classes typically broadcast notifications or request information by sending a message on a delegate class (Objective-C delegate).
</p><p>This model, while fully supported and surfaced by MonoMac can sometimes be cumbersome. MonoMac exposes the C# event pattern and a method-callback system on the class that can be used in these situations. This allows code like this to run:
</p>
<pre class="csharp" style="font-family:monospace;">button<span style="color: #008000;">.</span><span style="color: #0000FF;">Clicked</span> <span style="color: #008000;">+=</span> <span style="color: #6666cc; font-weight: bold;">delegate</span> <span style="color: #008000;">&#123;</span>
    Console<span style="color: #008000;">.</span><span style="color: #0000FF;">WriteLine</span> <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;I was clicked&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
<span style="color: #008000;">&#125;</span><span style="color: #008000;">;</span></pre>
<p>The binding generator is capable of reducing the amount of typing required to map the Objective-C pattern into the C# pattern. 
</p><p>Is is also possible to instruct the generator to produce bindings for a specific Objective-C delegates and expose the delegate as C# events and properties on the host type.
</p><p>There are two classes involved in this process, the host class which will is the one that currently emits events and sends those into the Delegate or WeakDelegate and the actual delegate class. 
</p><p>Considering the following setup:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>BaseType <span style="color: #008000;">&#40;</span><a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a> <span style="color: #008000;">&#40;</span>NSObject<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">interface</span> MyClass <span style="color: #008000;">&#123;</span>
    <span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;delegate&quot;</span>, ArgumentSemantic<span style="color: #008000;">.</span><span style="color: #0000FF;">Assign</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">&#91;</span>NullAllowed<span style="color: #008000;">&#93;</span>
    NSObject WeakDelegate <span style="color: #008000;">&#123;</span> <span style="color: #0600FF; font-weight: bold;">get</span><span style="color: #008000;">;</span> <span style="color: #0600FF; font-weight: bold;">set</span><span style="color: #008000;">;</span> <span style="color: #008000;">&#125;</span>
&#160;
    <span style="color: #008000;">&#91;</span>Wrap <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;WeakDelegate&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">&#91;</span>NullAllowed<span style="color: #008000;">&#93;</span>
    MyClassDelegate <span style="color: #6666cc; font-weight: bold;">Delegate</span> <span style="color: #008000;">&#123;</span> <span style="color: #0600FF; font-weight: bold;">get</span><span style="color: #008000;">;</span> <span style="color: #0600FF; font-weight: bold;">set</span><span style="color: #008000;">;</span> <span style="color: #008000;">&#125;</span>
<span style="color: #008000;">&#125;</span>
&#160;
<span style="color: #008000;">&#91;</span>BaseType <span style="color: #008000;">&#40;</span><a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a> <span style="color: #008000;">&#40;</span>NSObject<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">interface</span> MyClassDelegate <span style="color: #008000;">&#123;</span>
    <span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;loaded:bytes:&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #6666cc; font-weight: bold;">void</span> Loaded <span style="color: #008000;">&#40;</span>MyClass sender, <span style="color: #6666cc; font-weight: bold;">int</span> bytes<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
<span style="color: #008000;">&#125;</span></pre>
<p>To wrap the class you must:
</p>
<ul><li> In your host class, add to your [BaseType] declaration the type that is acting as its delegate and the C# name that you exposed. In our example above those are "typeof (MyClassDelegate)" and "WeakDelegate" respectively.&lt;/li&gt;
</li><li> In your delegate class, on each method that has more than two parameters, you need to specify the type that you want to use for the automatically generated EventArgs class.&lt;/li&gt;
</li></ul>
<p>The binding generator is not limited to wrapping only a single event destination, it is possible that some Objective-C classes to emit messages to more than one delegate, so you will have to provide arrays to support this setup. Most setups will not need it, but the generator is ready to support those cases.
</p><p>The resulting code will be:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>BaseType <span style="color: #008000;">&#40;</span><a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a> <span style="color: #008000;">&#40;</span>NSObject<span style="color: #008000;">&#41;</span>,
    Delegates<span style="color: #008000;">=</span><a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> <span style="color: #6666cc; font-weight: bold;">string</span> <span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span> <span style="color: #008000;">&#123;</span><span style="color: #666666;">&quot;WeakDelegate&quot;</span><span style="color: #008000;">&#125;</span>, 
    Events<span style="color: #008000;">=</span><a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> Type <span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span> <span style="color: #008000;">&#40;</span><a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a> <span style="color: #008000;">&#40;</span>MyClassDelegate<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">interface</span> MyClass <span style="color: #008000;">&#123;</span>
    <span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;delegate&quot;</span>, ArgumentSemantic<span style="color: #008000;">.</span><span style="color: #0000FF;">Assign</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">&#91;</span>NullAllowed<span style="color: #008000;">&#93;</span>
    NSObject WeakDelegate <span style="color: #008000;">&#123;</span> <span style="color: #0600FF; font-weight: bold;">get</span><span style="color: #008000;">;</span> <span style="color: #0600FF; font-weight: bold;">set</span><span style="color: #008000;">;</span> <span style="color: #008000;">&#125;</span>
&#160;
    <span style="color: #008000;">&#91;</span>Wrap <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;WeakDelegate&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span><span style="color: #008000;">&#91;</span>NullAllowed<span style="color: #008000;">&#93;</span>
    MyClassDelegate <span style="color: #6666cc; font-weight: bold;">Delegate</span> <span style="color: #008000;">&#123;</span> <span style="color: #0600FF; font-weight: bold;">get</span><span style="color: #008000;">;</span> <span style="color: #0600FF; font-weight: bold;">set</span><span style="color: #008000;">;</span> <span style="color: #008000;">&#125;</span>
<span style="color: #008000;">&#125;</span>
&#160;
<span style="color: #008000;">&#91;</span>BaseType <span style="color: #008000;">&#40;</span><a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a> <span style="color: #008000;">&#40;</span>NSObject<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">interface</span> MyClassDelegate <span style="color: #008000;">&#123;</span>
    <span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;loaded:bytes:&quot;</span><span style="color: #008000;">&#41;</span>, EventArgs <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;MyClassLoaded&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
    <span style="color: #6666cc; font-weight: bold;">void</span> Loaded <span style="color: #008000;">&#40;</span>MyClass sender, <span style="color: #6666cc; font-weight: bold;">int</span> bytes<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
<span style="color: #008000;">&#125;</span></pre>
<p>The EventArgs is used to specify the name of the EventArgs class to be generated. You should use one per signature (in this example, the EventArgs will contain a "With" property of type int).
</p><p>With the definitions above, the generator will produce the following event in the generated MyClass:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #0600FF; font-weight: bold;">public</span> MyClassLoadedEventArgs <span style="color: #008000;">:</span> EventArgs <span style="color: #008000;">&#123;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> MyClassLoadedEventArgs <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">int</span> bytes<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">int</span> Bytes <span style="color: #008000;">&#123;</span> <span style="color: #0600FF; font-weight: bold;">get</span><span style="color: #008000;">;</span> <span style="color: #0600FF; font-weight: bold;">set</span><span style="color: #008000;">;</span> <span style="color: #008000;">&#125;</span>
<span style="color: #008000;">&#125;</span>
&#160;
<span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #0600FF; font-weight: bold;">event</span> EventHandler<span style="color: #008000;">&amp;</span>lt<span style="color: #008000;">;</span>MyClassLoadedEventArgs<span style="color: #008000;">&amp;</span>gt<span style="color: #008000;">;</span> Loaded <span style="color: #008000;">&#123;</span> 
    <span style="color: #0600FF; font-weight: bold;">add</span><span style="color: #008000;">;</span> <span style="color: #0600FF; font-weight: bold;">remove</span><span style="color: #008000;">;</span> 
<span style="color: #008000;">&#125;</span></pre>
<p>So you can now use the code like this:
</p>
<pre class="csharp" style="font-family:monospace;">MyClass c <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> MyClass <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
c<span style="color: #008000;">.</span><span style="color: #0000FF;">Loaded</span> <span style="color: #008000;">+=</span> <span style="color: #6666cc; font-weight: bold;">delegate</span> <span style="color: #008000;">&#40;</span>sender, args<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#123;</span>
    Console<span style="color: #008000;">.</span><span style="color: #0000FF;">WriteLine</span> <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;Loaded event with {0} bytes&quot;</span>, args<span style="color: #008000;">.</span><span style="color: #0000FF;">Bytes</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
<span style="color: #008000;">&#125;</span><span style="color: #008000;">;</span></pre>
<p>Callbacks are just like event invocations, the difference is that instead of having multiple potential subscribers (for example, multiple methods can hook into a "Clicked" event or a "Download Finished" event) callbacks can only have a single subscriber.
</p><p>The process is identical, the only difference is that instead of exposing the name of the EventArgs class that will be generated, the EventArgs actually is used to name the resulting C# delegate name.
</p><p>If the method in the delegate class returns a value, the binding generator will map this into a delegate method in the parent class instead of an event. In these cases you need to provide the default value  that should be returned by the method if the user does not hook up to the delegate. You do this using the [DefaultValue] or [DefaultValueFromArgument] attributes.
</p><p>DefaultValue will hardcode a return value, while [DefaultValueFromArgument] is used to specify which input argument will be returned. 
</p>
<h2> <span class="mw-headline" id="Enumerations_and_Base_Types">Enumerations and Base Types</span></h2>
<p>You can also reference enumerations or base types that are not directly supported by the btouch interface definition system. To do this, put your enumerations and core types into a separate file and include this as part of one of the extra files that you provide to btouch.
</p>
<h2> <span class="mw-headline" id="out.2Fref_parameters">out/ref parameters</span></h2>
<p>Some APIs return values in their parameters, or pass parameters by reference. The MonoMac generator have support for binding out/ref parameters that are subclasses of NSObject.
</p><p>Typically the signature looks like this::
</p>
<pre>- (void) someting:(int) foo withError:(NSError **) return
- (void) someString:(NSObject **)byref
</pre>
<p>Your binding would look like this:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;something:withError:&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">void</span> Something <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">int</span> foo, <span style="color: #0600FF; font-weight: bold;">out</span> NSError error<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
<span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;someString:&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">void</span> SomeString <span style="color: #008000;">&#40;</span><span style="color: #0600FF; font-weight: bold;">ref</span> NSObject byref<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<h2> <span class="mw-headline" id="Binding_Objective-C_Argument_Lists">Binding Objective-C Argument Lists</span></h2>
<p>Objective-C supports variadic arguments, you can use the following technique described by Zach Gris on <a href="http://forums.monotouch.net/yaf_postst311_SOLVED-Binding-ObjectiveC-Argument-Lists.aspx" class="external text" rel="nofollow">this post</a>.
</p><p>An Objective-C message looks like this:
</p>
<pre>
- (void) appendWorkers:(XWorker *) firstWorker, ... NS_REQUIRES_NIL_TERMINATION&#160;;
</pre>
<p>To invoke this method from C# you will want to create a signature like this:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;appendWorkers&quot;</span><span style="color: #008000;">&#41;</span>, <span style="color: #0600FF; font-weight: bold;">Internal</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">void</span> AppendWorkers <span style="color: #008000;">&#40;</span>Worker firstWorker, IntPtr workersPtr<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<p>This declares the method as internal, hiding the above API from users, but exposing it to the library. Then you can write a method like this:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #0600FF; font-weight: bold;">public</span> <span style="color: #6666cc; font-weight: bold;">void</span> AppendWorkers<span style="color: #008000;">&#40;</span><span style="color: #0600FF; font-weight: bold;">params</span> Worker<span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span> workers<span style="color: #008000;">&#41;</span>
<span style="color: #008000;">&#123;</span>
    <span style="color: #0600FF; font-weight: bold;">if</span> <span style="color: #008000;">&#40;</span>workers <span style="color: #008000;">==</span> <span style="color: #0600FF; font-weight: bold;">null</span><span style="color: #008000;">&#41;</span>
         <span style="color: #0600FF; font-weight: bold;">throw</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> ArgumentNullException <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;workers&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #0600FF; font-weight: bold;">var</span> pNativeArr <span style="color: #008000;">=</span> Marshal<span style="color: #008000;">.</span><span style="color: #0000FF;">AllocHGlobal</span><span style="color: #008000;">&#40;</span>workers<span style="color: #008000;">.</span><span style="color: #0000FF;">Length</span> <span style="color: #008000;">*</span> IntPtr<span style="color: #008000;">.</span><span style="color: #0000FF;">Size</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    <span style="color: #0600FF; font-weight: bold;">for</span> <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">int</span> i <span style="color: #008000;">=</span> <span style="color: #FF0000;">1</span><span style="color: #008000;">;</span> i <span style="color: #008000;">&amp;</span>lt<span style="color: #008000;">;</span> workers<span style="color: #008000;">.</span><span style="color: #0000FF;">Length</span><span style="color: #008000;">;</span> <span style="color: #008000;">++</span>i<span style="color: #008000;">&#41;</span>
        Marshal<span style="color: #008000;">.</span><span style="color: #0000FF;">WriteIntPtr</span> <span style="color: #008000;">&#40;</span>pNativeArr, <span style="color: #008000;">&#40;</span>i <span style="color: #008000;">-</span> <span style="color: #FF0000;">1</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">*</span> IntPtr<span style="color: #008000;">.</span><span style="color: #0000FF;">Size</span>, workers<span style="color: #008000;">&#91;</span>i<span style="color: #008000;">&#93;</span><span style="color: #008000;">.</span><span style="color: #0000FF;">Handle</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// Null termination</span>
    Marshal<span style="color: #008000;">.</span><span style="color: #0000FF;">WriteIntPtr</span> <span style="color: #008000;">&#40;</span>pNativeArr, <span style="color: #008000;">&#40;</span>workers<span style="color: #008000;">.</span><span style="color: #0000FF;">Length</span> <span style="color: #008000;">-</span> <span style="color: #FF0000;">1</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">*</span> IntPtr<span style="color: #008000;">.</span><span style="color: #0000FF;">Size</span>, IntPtr<span style="color: #008000;">.</span><span style="color: #0000FF;">Zero</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
&#160;
    <span style="color: #008080; font-style: italic;">// the signature for this method has gone from (IntPtr, IntPtr) to (Worker, IntPtr)</span>
    WorkerManager<span style="color: #008000;">.</span><span style="color: #0000FF;">AppendWorkers</span><span style="color: #008000;">&#40;</span>workers<span style="color: #008000;">&#91;</span><span style="color: #FF0000;">0</span><span style="color: #008000;">&#93;</span>, pNativeArr<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
    Marshal<span style="color: #008000;">.</span><span style="color: #0000FF;">FreeHGlobal</span><span style="color: #008000;">&#40;</span>pNativeArr<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
<span style="color: #008000;">&#125;</span></pre>
<h2> <span class="mw-headline" id="Binding_Fields">Binding Fields</span></h2>
<p>There is also support for binding fields in a declaration. This simplifies the process of accessing a value that is declared in an external library from C#.
</p><p>Usually these fields contain strings or integers values that must be referenced. They are commonly used as string that represent a specific notification and as keys in dictionaries.
</p><p>To bind a field, add a read-only property to your interface definition file, and decorate the property with the [Field] attribute. This attribute takes one parameter: the C name of the symbol to lookup. For example:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>Field <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;NSSomeEventNotification&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">string</span> NSSomeEventNotification <span style="color: #008000;">&#123;</span> <span style="color: #0600FF; font-weight: bold;">get</span><span style="color: #008000;">;</span> <span style="color: #008000;">&#125;</span></pre>
<h2> <span class="mw-headline" id="Binding_Blocks">Binding Blocks</span></h2>
<p>Blocks are a new construct introduced by Apple to bring the functional equivalent of C# anonymous methods to Objective-C. For example, the NSSet class now exposes this method:
</p>
<pre>
- (void) enumerateObjectsUsingBlock:(void (^)(id obj, BOOL *stop)) block
</pre>
<p>The above description declares a method called <i>enumerateObjectsUsingBlock:</i> that takes one argument named <i>block</i>. This block is similar to a C# anonymous method in that it has support for capturing the current environment (the "this" pointer, access to local variables and parameters). The above method in NSSet invokes the block with two parameters an NSObject (the <i>id obj</i> part) and a pointer to a boolean (the <i>BOOL *stop</i>) part.
</p><p>To bind this kind of API with bmap, you need to first declare the block type signature as a C# delegate and then reference it from an API entry point, like this:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008080; font-style: italic;">// This declares the callback signature for the block:</span>
<span style="color: #6666cc; font-weight: bold;">delegate</span> <span style="color: #6666cc; font-weight: bold;">void</span> NSSetEnumerator <span style="color: #008000;">&#40;</span>NSObject obj, <span style="color: #0600FF; font-weight: bold;">ref</span> <span style="color: #6666cc; font-weight: bold;">bool</span> stop<span style="color: #008000;">&#41;</span>
&#160;
<span style="color: #008080; font-style: italic;">// Later, inside your definition, do this:</span>
<span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;enumerateObjectUsingBlock:&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">void</span> Enumerate <span style="color: #008000;">&#40;</span>NSSetEnumerator <span style="color: #6666cc; font-weight: bold;">enum</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
<span style="color: #008000;">&lt;/</span>pre<span style="color: #008000;">&gt;</span>
&#160;
And now your code can call your function <span style="color: #0600FF; font-weight: bold;">from</span> C<span style="color: #008080;">#:</span>
<span style="color: #008000;">&lt;</span>csharp<span style="color: #008000;">&gt;</span>
<span style="color: #0600FF; font-weight: bold;">var</span> myset <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> NSMutableSet <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#123;</span> <span style="color: #0600FF; font-weight: bold;">Add</span> <span style="color: #008000;">&#40;</span><a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> NSString <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;Foo&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#125;</span><span style="color: #008000;">;</span>
&#160;
s<span style="color: #008000;">.</span><span style="color: #0000FF;">Enumerate</span> <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">delegate</span> <span style="color: #008000;">&#40;</span>NSObject obj, <span style="color: #0600FF; font-weight: bold;">ref</span> <span style="color: #6666cc; font-weight: bold;">bool</span> stop<span style="color: #008000;">&#41;</span><span style="color: #008000;">&#123;</span>
    Console<span style="color: #008000;">.</span><span style="color: #0000FF;">WriteLine</span> <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;The first object is: {0} and stop is: {1}&quot;</span>, obj, stop<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
<span style="color: #008000;">&#125;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<p>You can also use lambdas if you prefer:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #0600FF; font-weight: bold;">var</span> myset <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> NSMutableSet <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#123;</span> <span style="color: #0600FF; font-weight: bold;">Add</span> <span style="color: #008000;">&#40;</span><a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> NSString <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;Foo&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#125;</span><span style="color: #008000;">;</span>
&#160;
s<span style="color: #008000;">.</span><span style="color: #0000FF;">Enumerate</span> <span style="color: #008000;">&#40;</span><span style="color: #008000;">&#40;</span>obj, stop<span style="color: #008000;">&#41;</span> <span style="color: #008000;">=&amp;</span>gt<span style="color: #008000;">;</span> <span style="color: #008000;">&#123;</span>
    Console<span style="color: #008000;">.</span><span style="color: #0000FF;">WriteLine</span> <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;The first object is: {0} and stop is: {1}&quot;</span>, obj, stop<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
<span style="color: #008000;">&#125;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span></pre>
<h2> <span class="mw-headline" id="Linking_the_Dependencies">Linking the Dependencies</span></h2>
<p>If you are binding APIs that are not part of your application, you need to make sure that your executable is linked against these libraries.
</p><p>On the project options for your final executable (not the library itself, but the final program) you need to add in "iPhone Build's" Extra argument (these are part of your project options) the "-gcc_flags" option followed by a quoted string that contains all the extra libraries that are required for your program, for example:
</p>
<pre>
-gcc_flags &quot;-L${ProjectDir} -lMylibrary -force_load -lSystemLibrary -framework CFNetwork -ObjC&quot;
</pre>
<p>The above example will link <i>libMyLibrary.a</i>, <i>libSystemLibrary.dylib</i> and the <i>CFNetwork</i> framework library into your final executable. 
</p><p>You might be wondering, why do you need "force_load" command, and the reason is that the -ObjC flag although it compiles the code in, it does not preserve the metadata required to support categories (the linker/compiler dead code elimination strips it) which you need at runtime for MonoMac.
</p>
<h2> <span class="mw-headline" id="Assisted_References">Assisted References </span></h2>
<p>Some transient objects like action sheets and alert boxes are cumbersome to keep track of for developers and the binding generator can help a little bit here.
</p><p>For example if you had a class that showed a message and then generated a "Done" event, the traditional way of handling this would be:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #6666cc; font-weight: bold;">class</span> Demo <span style="color: #008000;">&#123;</span>
    MessageBox box<span style="color: #008000;">;</span>
&#160;
    <span style="color: #6666cc; font-weight: bold;">void</span> ShowError <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">string</span> msg<span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
        box <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> MessageBox <span style="color: #008000;">&#40;</span>msg<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
        box<span style="color: #008000;">.</span><span style="color: #0000FF;">Done</span> <span style="color: #008000;">+=</span> <span style="color: #008000;">&#123;</span> box <span style="color: #008000;">=</span> <span style="color: #0600FF; font-weight: bold;">null</span><span style="color: #008000;">;</span> <span style="color: #008000;">...</span> <span style="color: #008000;">&#125;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
<span style="color: #008000;">&#125;</span></pre>
<p>In the above scenario the developer needs to keep the reference to the object himself and either leak or actively clear the reference for box on his own. While binding code, the generator supports keeping track of the reference for you and clear it when a special method is invoked, the above code would then become:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #6666cc; font-weight: bold;">class</span> Demo <span style="color: #008000;">&#123;</span>
    <span style="color: #6666cc; font-weight: bold;">void</span> ShowError <span style="color: #008000;">&#40;</span><span style="color: #6666cc; font-weight: bold;">string</span> msg<span style="color: #008000;">&#41;</span>
    <span style="color: #008000;">&#123;</span>
        <span style="color: #0600FF; font-weight: bold;">var</span> box <span style="color: #008000;">=</span> <a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> MessageBox <span style="color: #008000;">&#40;</span>msg<span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span>
        box<span style="color: #008000;">.</span><span style="color: #0000FF;">Done</span> <span style="color: #008000;">+=</span> <span style="color: #008000;">&#123;</span> <span style="color: #008000;">...</span> <span style="color: #008000;">&#125;</span><span style="color: #008000;">;</span>
    <span style="color: #008000;">&#125;</span>
<span style="color: #008000;">&#125;</span></pre>
<p>Notice how it is no longer necessary to keep the variable in an instance, that it works with a local variable and that it is not necessary to clear the reference when the object dies.
</p><p>To take advantage of this, your class should have a Events property set in the [BaseType] declaration and also the KeepUntilRef variable set to the name of the method that is invoked when the object has completed its work, like this:
</p>
<pre class="csharp" style="font-family:monospace;"><span style="color: #008000;">&#91;</span>BaseType <span style="color: #008000;">&#40;</span><a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a> <span style="color: #008000;">&#40;</span>NSObject<span style="color: #008000;">&#41;</span>, KeepUntilRef<span style="color: #008000;">=</span><span style="color: #666666;">&quot;Dismiss&quot;</span><span style="color: #008000;">&#41;</span>, Delegates<span style="color: #008000;">=</span><a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> <span style="color: #6666cc; font-weight: bold;">string</span> <span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span> <span style="color: #008000;">&#123;</span> <span style="color: #666666;">&quot;WeakDelegate&quot;</span> <span style="color: #008000;">&#125;</span>, Events<span style="color: #008000;">=</span><a href="http://www.google.com/search?q=new+msdn.microsoft.com"><span style="color: #008000;">new</span></a> Type <span style="color: #008000;">&#91;</span><span style="color: #008000;">&#93;</span> <span style="color: #008000;">&#123;</span> <a href="http://www.google.com/search?q=typeof+msdn.microsoft.com"><span style="color: #008000;">typeof</span></a> <span style="color: #008000;">&#40;</span>SomeDelegate<span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#125;</span><span style="color: #008000;">&#41;</span> <span style="color: #008000;">&#93;</span>
<span style="color: #6666cc; font-weight: bold;">class</span> Demo <span style="color: #008000;">&#123;</span>
    <span style="color: #008000;">&#91;</span>Export <span style="color: #008000;">&#40;</span><span style="color: #666666;">&quot;show&quot;</span><span style="color: #008000;">&#41;</span><span style="color: #008000;">;</span><span style="color: #008000;">&#93;</span>
<span style="color: #008000;">&#125;</span></pre>
<h2> <span class="mw-headline" id="Inheriting_Protocols">Inheriting Protocols</span></h2>
<p>We support inheriting from protocols that have been marked with the [Model] property. This is useful in certain API patterns, such as in MapKit where the MKOverlay protocol, inherits from the MKAnnotation protocol, and is adopted by a number of classes which inherit from NSObject. Historically we required copying the protocol to every implementation, but in these cases now we can have the MKShape class inherit from the MKOverlay protocol and it will generate all the required methods automatically.
</p>
