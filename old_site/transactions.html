---
layout: obsolete
title: "Transactions"
permalink: /old_site/Transactions/
redirect_from:
  - /Transactions/
---

<h1>Transactions</h1>

<p>This page describes the status of transaction process in Mono as well as plans for future work.
</p><p>Transactions processing is described in:
</p>
<ul><li> <a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=AAC3D722-444C-4E27-8B2E-C6157ED16B15&amp;displaylang=en" class="external text" rel="nofollow">Introducing System.Transactions in the Microsoft .NET Framework version 2.0</a>
</li><li> <a href="http://msdn2.microsoft.com/en-us/library/w97s6fw4(en-US,VS.80).aspx" class="external text" rel="nofollow">Transaction Processing, .NET Framework documentation</a>
</li></ul>
<p>You might also be interested in <a href="{{site.github.url}}/old_site/System.Messaging">SystemMessaging</a>.
</p><p>On Microsoft.NET, System.Transactions is a wrapper around Microsoft's  distributed transaction manager (MSDTM) with some additional optimizations.  
</p><p>The optimizations are interesting and useful enough that we implemented them  without the MSDTM. 
</p><p>A "distributed transaction" is a transaction that has components of the transaction in different places, each place offering a local transaction ability.  The key algorithm is the 2-phase commit: a way to conjure up a globally consistent transactional commit out of individual commits in individual pieces. Thus a distributed transaction has a different flavour as compared to an individual database transaction.  It is abstract enough that it  can be implemented without knowledge of the actual mechanisms of each local transaction -- it only matters that there's a way to prepare for a commit, do  the commit, or do a rollback.
</p><p>However, the notions of "durable" vs. "volatile" are useful to discuss them, since individual pieces of a distributed system can fail independently, and thus the distributed transaction needs to be aware of the failure semantics.
</p><p>Thus it's not easy to build a practical distributed transaction manager without
knowing the actual failure behaviour of the individual pieces.
</p><p>The MS S.T "confuses" the two issues, since it is somewhat tied to the actual support of the MSDTM in MSSql. It provides only one way for a durable resource manager to register with a distributed transaction -- use the MSDTM. We may still be able to avoid the MSDTM and use an extension of our LTM to run the distributed transaction, but it will be more brittle, and behave differently from the MS implementation. The thing is that the API docs don't seem to offer the possibility of a third type of transaction manager (or maybe they do, but it's well hidden&#160;:-)
</p>
<h1> <span class="mw-headline" id="Using_Transactions_with_Databases"> Using Transactions with Databases </span></h1>
<p>From a discussion on the mailing list, Ankit said:
</p><p><a href="http://msdn2.microsoft.com/en-us/library/ms172152.aspx" class="external text" rel="nofollow">Implementing an Implicit Transaction using Transaction Scope</a>
</p><p>Transaction.Current property (ambient transaction) refers to the "current" transaction which can be used by DbCommand etc to find out whether it is being used in a transaction. 
</p><p><br />
</p>
<h1> <span class="mw-headline" id="Implementation_Details."> Implementation Details. </span></h1>
<p>Volatile and durable resource managers are available, and work with Single Phase Commit (SPC) and 2 Phase Commit (2PC).
</p>
<h1> <span class="mw-headline" id="Missing_Features"> Missing Features </span></h1>
<p>DependentTransaction is not implemented.
</p><p>Distributed transactions are not implemented, not because of a limitation in our code, but because we might end up with different behaviour.
</p><p>We want to implement this anyways.
</p>
