---
layout: obsolete
title: "Mono:Runtime:Documentation:Generics"
permalink: /old_site/Mono:Runtime:Documentation:Generics/
redirect_from:
  - /Mono:Runtime:Documentation:Generics/
---

<h1>Mono:Runtime:Documentation:Generics</h1>

<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Table of contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Terminology"><span class="tocnumber">1</span> <span class="toctext">Terminology</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Generic_Type_Definitions"><span class="tocnumber">2</span> <span class="toctext">Generic Type Definitions</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Generic_Type_Instantiations"><span class="tocnumber">3</span> <span class="toctext">Generic Type Instantiations</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Generic_Method_Definitions"><span class="tocnumber">4</span> <span class="toctext">Generic Method Definitions</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Generic_Method_Instantiations"><span class="tocnumber">5</span> <span class="toctext">Generic Method Instantiations</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#MonoGenericContext"><span class="tocnumber">6</span> <span class="toctext">MonoGenericContext</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Canonical_generic_instances"><span class="tocnumber">7</span> <span class="toctext">Canonical generic instances</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Lifetime_of_inflated_types.2Fmethods"><span class="tocnumber">8</span> <span class="toctext">Lifetime of inflated types/methods</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#System.Reflection.Emit"><span class="tocnumber">9</span> <span class="toctext">System.Reflection.Emit</span></a></li>
</ul>
</td></tr></table>
<h2> <span class="mw-headline" id="Terminology"> Terminology </span></h2>
<p>Type/Method instantiation == Type/Method instance == Inflated Type/Method.
</p>
<h2> <span class="mw-headline" id="Generic_Type_Definitions"> Generic Type Definitions </span></h2>
<p>These are represented by a normal <code>MonoClass</code> structure with the <code>generic_container</code> field set. This field points to a <code>MonoGenericContainer</code> structure, which stores information about the generic parameters of the generic type.
</p>
<h2> <span class="mw-headline" id="Generic_Type_Instantiations"> Generic Type Instantiations </span></h2>
<p>These are represented by a pair of <code>MonoGenericClass</code> and <code>MonoClass</code> structures. The <code>generic_class</code> field in MonoClass is used to link the two together. The reason for the split is to avoid allocating a large MonoClass if not needed.
</p><p>It would have been better to name <code>MonoGenericClass</code> <code>MonoInflatedClass</code> or something similar. 
</p>
<h2> <span class="mw-headline" id="Generic_Method_Definitions"> Generic Method Definitions </span></h2>
<p>These are represented by a <code>MonoMethod</code> structure with the <code>is_generic</code> field set to 1.
</p>
<h2> <span class="mw-headline" id="Generic_Method_Instantiations"> Generic Method Instantiations </span></h2>
<p>These are represented by a <code>MonoMethodInflated</code> structure, which is an extension of the <code>MonoMethod</code> structure. Its <code>is_inflated</code> field is set to 1.
</p><p>One consequence of this design is that a method cannot be a pinvoke method/wrapper/dynamic method and an inflated method at the same time.
</p>
<h2> <span class="mw-headline" id="MonoGenericContext"> MonoGenericContext </span></h2>
<p>This structure holds information of an instantiation of a set of generic parameters with generic arguments. It is used by both type and method instatiations.
</p>
<h2> <span class="mw-headline" id="Canonical_generic_instances"> Canonical generic instances </span></h2>
<p>The runtime canonizes generic type/method instances, so for every set of generic arguments, there is only one type/method instance with those arguments. This is using caches in <code>metadata.c</code>.
</p>
<h2> <span class="mw-headline" id="Lifetime_of_inflated_types.2Fmethods"> Lifetime of inflated types/methods </span></h2>
<p>Inflated types and methods depend on the assembly of the generic type/method definition they are inflated from, along with the assemblies of their generic arguments. This is handled using the concept of 'image sets' in metadata.c.
Every inflated type/method belongs to an image set, which is a set of MonoImages. When one of the assemblies in an image set is unloaded, all the inflated types/methods belonging to the image set are freed.
Memory for inflated types/methods cannot be allocated from mempools, it is allocated from the heap. The <code>mono_class_alloc/alloc0</code> functions can be used to allocate memory from the appropriate place.
</p>
<h2> <span class="mw-headline" id="System.Reflection.Emit"> System.Reflection.Emit </span></h2>
<p>Generics support in System.Reflection.Emit (SRE) is very problematic because it is possible to create generic instances of not yet created dynamic types, i.e. if T is a generic TypeBuilder, it is possible to create T&lt;int&gt;. The latter is not a TypeBuilder any more, but a normal Type, which presents several problems:
</p>
<ul><li> this type needs to be kept in sync with the original TypeBuilder, i.e. if methods/fields are added to the TypeBuilder, this should be reflected in the instantiation.
</li><li> this type cannot be used normally until its TypeBuilder is finished, ie. its not possible to create instances of it etc.
</li></ul>
<p>These problems are currently handled by a hierarchy of C# classes which inherit from the normal reflection classes:
</p>
<ul><li> <code>MonoGenericClass</code> represents an instantiation of a generic TypeBuilder. MS.NET calls this <code>TypeBuilderInstantiation</code>, a much better name.
</li><li> <code>Method/Field/Event/PropertyOnTypeBuilderInst</code> represents a method/field etc. of a <code>MonoGenericClass</code>.
</li></ul>

